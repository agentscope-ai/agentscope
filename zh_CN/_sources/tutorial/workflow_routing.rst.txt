
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorial/workflow_routing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorial_workflow_routing.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorial_workflow_routing.py:


.. _routing:

Routing
==========================
在 AgentScope 中有两种实现 Routing 的方法，都简单易实现：

- 使用结构化输出的显式 routing
- 使用工具调用的隐式 routing

.. tip:: 考虑到智能体 routing 没有统一的标准/定义，我们遵循 `Building effective agents <https://www.anthropic.com/engineering/building-effective-agents>`_ 中的设置

显式 Routing
~~~~~~~~~~~~~~~~~~~~~~~~~~
在显式 routing 中，我们可以直接使用智能体的结构化输出来确定将消息路由到哪个智能体。

初始化 routing 智能体

.. GENERATED FROM PYTHON SOURCE LINES 20-83

.. code-block:: Python

    import asyncio
    import json
    import os
    from typing import Literal

    from pydantic import BaseModel, Field

    from agentscope.agent import ReActAgent
    from agentscope.formatter import DashScopeChatFormatter
    from agentscope.memory import InMemoryMemory
    from agentscope.message import Msg
    from agentscope.model import DashScopeChatModel
    from agentscope.tool import Toolkit, ToolResponse

    router = ReActAgent(
        name="Router",
        sys_prompt="你是一个路由智能体。你的目标是将用户查询路由到正确的后续任务，注意你不需要回答用户的问题。",
        model=DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        ),
        formatter=DashScopeChatFormatter(),
    )


    # 使用结构化输出指定路由任务
    class RoutingChoice(BaseModel):
        your_choice: Literal[
            "Content Generation",
            "Programming",
            "Information Retrieval",
            None,
        ] = Field(
            description="选择正确的后续任务，如果任务太简单或没有合适的任务，则选择 ``None``",
        )
        task_description: str | None = Field(
            description="任务描述",
            default=None,
        )


    async def example_router_explicit() -> None:
        """使用结构化输出进行显式路由的示例。"""
        msg_user = Msg(
            "user",
            "帮我写一首诗",
            "user",
        )

        # 路由查询
        msg_res = await router(
            msg_user,
            structured_model=RoutingChoice,
        )

        # 结构化输出存储在 metadata 字段中
        print("结构化输出：")
        print(json.dumps(msg_res.metadata, indent=4, ensure_ascii=False))


    asyncio.run(example_router_explicit())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/work/agentscope/agentscope/src/agentscope/model/_dashscope_model.py:231: DeprecationWarning: 'required' is not supported by DashScope API. It will be converted to 'auto'.
      warnings.warn(
    Router: {
        "type": "tool_use",
        "name": "generate_response",
        "input": {
            "your_choice": "Content Generation",
            "task_description": "用户请求帮助写一首诗"
        },
        "id": "call_887a2dbeca1b470b9dbd79"
    }
    system: {
        "type": "tool_result",
        "id": "call_887a2dbeca1b470b9dbd79",
        "name": "generate_response",
        "output": [
            {
                "type": "text",
                "text": "Successfully generated response."
            }
        ]
    }
    Router: 我将为您转接到专门负责诗歌创作的任务中，很快就会有美妙的诗句呈现在您面前。请稍等片刻！
    结构化输出：
    {
        "your_choice": "Content Generation",
        "task_description": "用户请求帮助写一首诗"
    }




.. GENERATED FROM PYTHON SOURCE LINES 84-90

隐式 Routing
~~~~~~~~~~~~~~~~~~~~~~~~~
另一种方法是将下游智能体包装成工具函数，这样路由智能体就可以根据用户查询决定调用哪个工具。

我们首先定义几个工具函数：


.. GENERATED FROM PYTHON SOURCE LINES 90-140

.. code-block:: Python



    async def generate_python(demand: str) -> ToolResponse:
        """根据需求生成 Python 代码。

        Args:
            demand (``str``):
                对 Python 代码的需求。
        """
        # 示例需求智能体
        python_agent = ReActAgent(
            name="PythonAgent",
            sys_prompt="你是一个 Python 专家，你的目标是根据需求生成 Python 代码。",
            model=DashScopeChatModel(
                model_name="qwen-max",
                api_key=os.environ["DASHSCOPE_API_KEY"],
                stream=False,
            ),
            memory=InMemoryMemory(),
            formatter=DashScopeChatFormatter(),
            toolkit=Toolkit(),
        )
        msg_res = await python_agent(Msg("user", demand, "user"))

        return ToolResponse(
            content=msg_res.get_content_blocks("text"),
        )


    # 为演示目的模拟一些其他工具函数
    async def generate_poem(demand: str) -> ToolResponse:
        """根据需求生成诗歌。

        Args:
            demand (``str``):
                对诗歌的需求。
        """
        pass


    async def web_search(query: str) -> ToolResponse:
        """在网络上搜索查询。

        Args:
            query (``str``):
                要搜索的查询。
        """
        pass









.. GENERATED FROM PYTHON SOURCE LINES 141-143

之后，我们定义一个路由智能体并为其配备上述工具函数。


.. GENERATED FROM PYTHON SOURCE LINES 143-177

.. code-block:: Python


    toolkit = Toolkit()
    toolkit.register_tool_function(generate_python)
    toolkit.register_tool_function(generate_poem)
    toolkit.register_tool_function(web_search)

    # 使用工具模块初始化路由智能体
    router_implicit = ReActAgent(
        name="Router",
        sys_prompt="你是一个路由智能体。你的目标是将用户查询路由到正确的后续任务。",
        model=DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        ),
        formatter=DashScopeChatFormatter(),
        toolkit=toolkit,
        memory=InMemoryMemory(),
    )


    async def example_router_implicit() -> None:
        """使用工具调用进行隐式路由的示例。"""
        msg_user = Msg(
            "user",
            "帮我在 Python 中生成一个快速排序函数",
            "user",
        )

        # 路由查询
        await router_implicit(msg_user)


    asyncio.run(example_router_implicit())




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Router: {
        "type": "tool_use",
        "name": "generate_python",
        "input": {
            "demand": "生成一个快速排序函数"
        },
        "id": "call_52f943ad08874b2f906adb"
    }
    PythonAgent: 快速排序是一种高效的排序算法，采用分治策略来对一个数组进行排序。下面是一个使用 Python 实现的快速排序函数：

    ```python
    def quicksort(arr):
        if len(arr) <= 1:
            return arr
        else:
            pivot = arr[len(arr) // 2]  # 选择中间的元素作为基准
            left = [x for x in arr if x < pivot]  # 小于基准的元素
            middle = [x for x in arr if x == pivot]  # 等于基准的元素
            right = [x for x in arr if x > pivot]  # 大于基准的元素
            return quicksort(left) + middle + quicksort(right)  # 递归排序左右子数组并合并

    # 示例用法
    arr = [3, 6, 8, 10, 1, 2, 1]
    sorted_arr = quicksort(arr)
    print(sorted_arr)
    ```

    这个实现中，我们选择了数组的中间元素作为基准（pivot），然后将数组分成三部分：小于基准的元素、等于基准的元素和大于基准的元素。接着对小于基准和大于基准的部分递归地进行快速排序，最后将结果合并。

    如果你希望使用原地排序（即不使用额外的空间），可以参考以下实现：

    ```python
    def quicksort_inplace(arr, low, high):
        if low < high:
            pi = partition(arr, low, high)  # 分区操作
            quicksort_inplace(arr, low, pi - 1)  # 递归排序左子数组
            quicksort_inplace(arr, pi + 1, high)  # 递归排序右子数组

    def partition(arr, low, high):
        pivot = arr[high]  # 选择最后一个元素作为基准
        i = low - 1  # 指向小于基准的最后一个元素
        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]  # 交换元素
        arr[i + 1], arr[high] = arr[high], arr[i + 1]  # 将基准放到正确的位置
        return i + 1

    # 示例用法
    arr = [3, 6, 8, 10, 1, 2, 1]
    quicksort_inplace(arr, 0, len(arr) - 1)
    print(arr)
    ```

    在这个实现中，`partition` 函数用于将数组分区，并返回基准元素的最终位置。`quicksort_inplace` 函数通过递归调用自身来对左右子数组进行排序。这样可以在原地完成排序，不需要额外的空间。
    system: {
        "type": "tool_result",
        "id": "call_52f943ad08874b2f906adb",
        "name": "generate_python",
        "output": [
            {
                "type": "text",
                "text": "快速排序是一种高效的排序算法，采用分治策略来对一个数组进行排序。下面是一个使用 Python 实现的快速排序函数：\n\n```python\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[len(arr) // 2]  # 选择中间的元素作为基准\n        left = [x for x in arr if x < pivot]  # 小于基准的元素\n        middle = [x for x in arr if x == pivot]  # 等于基准的元素\n        right = [x for x in arr if x > pivot]  # 大于基准的元素\n        return quicksort(left) + middle + quicksort(right)  # 递归排序左右子数组并合并\n\n# 示例用法\narr = [3, 6, 8, 10, 1, 2, 1]\nsorted_arr = quicksort(arr)\nprint(sorted_arr)\n```\n\n这个实现中，我们选择了数组的中间元素作为基准（pivot），然后将数组分成三部分：小于基准的元素、等于基准的元素和大于基准的元素。接着对小于基准和大于基准的部分递归地进行快速排序，最后将结果合并。\n\n如果你希望使用原地排序（即不使用额外的空间），可以参考以下实现：\n\n```python\ndef quicksort_inplace(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)  # 分区操作\n        quicksort_inplace(arr, low, pi - 1)  # 递归排序左子数组\n        quicksort_inplace(arr, pi + 1, high)  # 递归排序右子数组\n\ndef partition(arr, low, high):\n    pivot = arr[high]  # 选择最后一个元素作为基准\n    i = low - 1  # 指向小于基准的最后一个元素\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]  # 交换元素\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]  # 将基准放到正确的位置\n    return i + 1\n\n# 示例用法\narr = [3, 6, 8, 10, 1, 2, 1]\nquicksort_inplace(arr, 0, len(arr) - 1)\nprint(arr)\n```\n\n在这个实现中，`partition` 函数用于将数组分区，并返回基准元素的最终位置。`quicksort_inplace` 函数通过递归调用自身来对左右子数组进行排序。这样可以在原地完成排序，不需要额外的空间。"
            }
        ]
    }
    Router: 生成的 Python 代码中包含了一个快速排序函数，这里提供了两种实现方式：

    1. 第一种是非原地排序的实现，它使用了额外的空间来存储小于、等于和大于基准值的元素，并将这些部分递归地进行排序然后合并。
       ```python
       def quicksort(arr):
           if len(arr) <= 1:
               return arr
           else:
               pivot = arr[len(arr) // 2]
               left = [x for x in arr if x < pivot]
               middle = [x for x in arr if x == pivot]
               right = [x for x in arr if x > pivot]
               return quicksort(left) + middle + quicksort(right)

       # 使用示例
       arr = [3, 6, 8, 10, 1, 2, 1]
       sorted_arr = quicksort(arr)
       print(sorted_arr)
       ```

    2. 第二种是原地排序的实现，它通过交换数组中的元素来达到排序的目的，不需要额外的空间。
       ```python
       def quicksort_inplace(arr, low, high):
           if low < high:
               pi = partition(arr, low, high)
               quicksort_inplace(arr, low, pi - 1)
               quicksort_inplace(arr, pi + 1, high)

       def partition(arr, low, high):
           pivot = arr[high]
           i = low - 1
           for j in range(low, high):
               if arr[j] <= pivot:
                   i += 1
                   arr[i], arr[j] = arr[j], arr[i]
           arr[i + 1], arr[high] = arr[high], arr[i + 1]
           return i + 1

       # 使用示例
       arr = [3, 6, 8, 10, 1, 2, 1]
       quicksort_inplace(arr, 0, len(arr) - 1)
       print(arr)
       ```

    你可以根据你的需求选择适合的实现。如果你关心空间复杂度，那么第二种原地排序的方法会更合适。如果你的代码更注重简洁性和可读性，第一种方法可能更适合你。





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 0.239 seconds)


.. _sphx_glr_download_tutorial_workflow_routing.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: workflow_routing.ipynb <workflow_routing.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: workflow_routing.py <workflow_routing.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: workflow_routing.zip <workflow_routing.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
