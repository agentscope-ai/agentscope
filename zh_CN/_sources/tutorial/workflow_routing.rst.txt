
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorial/workflow_routing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorial_workflow_routing.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorial_workflow_routing.py:


.. _routing:

Routing
==========================
在 AgentScope 中有两种实现 Routing 的方法，都简单易实现：

- 使用结构化输出的显式 routing
- 使用工具调用的隐式 routing

.. tip:: 考虑到智能体 routing 没有统一的标准/定义，我们遵循 `Building effective agents <https://www.anthropic.com/engineering/building-effective-agents>`_ 中的设置

显式 Routing
~~~~~~~~~~~~~~~~~~~~~~~~~~
在显式 routing 中，我们可以直接使用智能体的结构化输出来确定将消息路由到哪个智能体。

初始化 routing 智能体

.. GENERATED FROM PYTHON SOURCE LINES 20-83

.. code-block:: Python

    import asyncio
    import json
    import os
    from typing import Literal

    from pydantic import BaseModel, Field

    from agentscope.agent import ReActAgent
    from agentscope.formatter import DashScopeChatFormatter
    from agentscope.memory import InMemoryMemory
    from agentscope.message import Msg
    from agentscope.model import DashScopeChatModel
    from agentscope.tool import Toolkit, ToolResponse

    router = ReActAgent(
        name="Router",
        sys_prompt="你是一个路由智能体。你的目标是将用户查询路由到正确的后续任务，注意你不需要回答用户的问题。",
        model=DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        ),
        formatter=DashScopeChatFormatter(),
    )


    # 使用结构化输出指定路由任务
    class RoutingChoice(BaseModel):
        your_choice: Literal[
            "Content Generation",
            "Programming",
            "Information Retrieval",
            None,
        ] = Field(
            description="选择正确的后续任务，如果任务太简单或没有合适的任务，则选择 ``None``",
        )
        task_description: str | None = Field(
            description="任务描述",
            default=None,
        )


    async def example_router_explicit() -> None:
        """使用结构化输出进行显式路由的示例。"""
        msg_user = Msg(
            "user",
            "帮我写一首诗",
            "user",
        )

        # 路由查询
        msg_res = await router(
            msg_user,
            structured_model=RoutingChoice,
        )

        # 结构化输出存储在 metadata 字段中
        print("结构化输出：")
        print(json.dumps(msg_res.metadata, indent=4, ensure_ascii=False))


    asyncio.run(example_router_explicit())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/work/agentscope/agentscope/src/agentscope/model/_dashscope_model.py:203: DeprecationWarning: 'required' is not supported by DashScope API. It will be converted to 'auto'.
      warnings.warn(
    Router: {
        "type": "tool_use",
        "name": "generate_response",
        "input": {
            "your_choice": "Content Generation",
            "task_description": "用户请求帮助写一首诗"
        },
        "id": "call_5177b719f1ab4453ad0177"
    }
    system: {
        "type": "tool_result",
        "id": "call_5177b719f1ab4453ad0177",
        "name": "generate_response",
        "output": [
            {
                "type": "text",
                "text": "Successfully generated response."
            }
        ]
    }
    Router: 我已经将您的请求转给了我们的内容创作团队，他们很快就会帮您创作一首诗。请您稍等片刻！
    结构化输出：
    {
        "your_choice": "Content Generation",
        "task_description": "用户请求帮助写一首诗"
    }




.. GENERATED FROM PYTHON SOURCE LINES 84-90

隐式 Routing
~~~~~~~~~~~~~~~~~~~~~~~~~
另一种方法是将下游智能体包装成工具函数，这样路由智能体就可以根据用户查询决定调用哪个工具。

我们首先定义几个工具函数：


.. GENERATED FROM PYTHON SOURCE LINES 90-140

.. code-block:: Python



    async def generate_python(demand: str) -> ToolResponse:
        """根据需求生成 Python 代码。

        Args:
            demand (``str``):
                对 Python 代码的需求。
        """
        # 示例需求智能体
        python_agent = ReActAgent(
            name="PythonAgent",
            sys_prompt="你是一个 Python 专家，你的目标是根据需求生成 Python 代码。",
            model=DashScopeChatModel(
                model_name="qwen-max",
                api_key=os.environ["DASHSCOPE_API_KEY"],
                stream=False,
            ),
            memory=InMemoryMemory(),
            formatter=DashScopeChatFormatter(),
            toolkit=Toolkit(),
        )
        msg_res = await python_agent(Msg("user", demand, "user"))

        return ToolResponse(
            content=msg_res.get_content_blocks("text"),
        )


    # 为演示目的模拟一些其他工具函数
    async def generate_poem(demand: str) -> ToolResponse:
        """根据需求生成诗歌。

        Args:
            demand (``str``):
                对诗歌的需求。
        """
        pass


    async def web_search(query: str) -> ToolResponse:
        """在网络上搜索查询。

        Args:
            query (``str``):
                要搜索的查询。
        """
        pass









.. GENERATED FROM PYTHON SOURCE LINES 141-143

之后，我们定义一个路由智能体并为其配备上述工具函数。


.. GENERATED FROM PYTHON SOURCE LINES 143-177

.. code-block:: Python


    toolkit = Toolkit()
    toolkit.register_tool_function(generate_python)
    toolkit.register_tool_function(generate_poem)
    toolkit.register_tool_function(web_search)

    # 使用工具模块初始化路由智能体
    router_implicit = ReActAgent(
        name="Router",
        sys_prompt="你是一个路由智能体。你的目标是将用户查询路由到正确的后续任务。",
        model=DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        ),
        formatter=DashScopeChatFormatter(),
        toolkit=toolkit,
        memory=InMemoryMemory(),
    )


    async def example_router_implicit() -> None:
        """使用工具调用进行隐式路由的示例。"""
        msg_user = Msg(
            "user",
            "帮我在 Python 中生成一个快速排序函数",
            "user",
        )

        # 路由查询
        await router_implicit(msg_user)


    asyncio.run(example_router_implicit())




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Router: {
        "type": "tool_use",
        "name": "generate_python",
        "input": {
            "demand": "生成一个快速排序函数"
        },
        "id": "call_4619cdacc71e448f91c2f2"
    }
    PythonAgent: 快速排序是一种高效的排序算法，它使用分治策略来把一个序列分为两个子序列。这里我将提供一个 Python 实现的快速排序函数。这个实现会包括递归地对数组进行划分，并在每次递归调用中选择一个“基准”元素来对数组进行分割。

    下面是快速排序的一个基本版本：

    ```python
    def quicksort(arr):
        # 递归终止条件：如果数组长度小于等于1，则不需要排序
        if len(arr) <= 1:
            return arr
        else:
            # 选择基准值，这里我们简单地选择列表中的第一个元素
            pivot = arr[0]
        
            # 所有小于基准值的元素组成的子数组
            less = [i for i in arr[1:] if i <= pivot]
        
            # 所有大于基准值的元素组成的子数组
            greater = [i for i in arr[1:] if i > pivot]

            # 递归地对左右两边的子数组进行快速排序，然后与基准值合并
            return quicksort(less) + [pivot] + quicksort(greater)

    # 示例
    arr = [3, 6, 8, 10, 1, 2, 1]
    sorted_arr = quicksort(arr)
    print(sorted_arr)
    ```

    这段代码定义了一个 `quicksort` 函数，该函数接受一个列表 `arr` 作为输入并返回一个新的已排序列表。这里使用了列表推导式来构建小于和大于基准值的元素列表。这种方法虽然简洁易懂，但在处理非常大的数据集时可能不是最优解，因为它涉及到创建新的列表，这可能会消耗较多内存。

    如果你需要更高效的空间利用或者想要了解如何在原地修改数组以减少空间复杂度，可以考虑使用另一种方式实现快速排序，例如通过交换元素而不是创建新列表。下面是一个原地排序的例子：

    ```python
    def partition(arr, low, high):
        i = (low-1)         # 最小元素索引
        pivot = arr[high]   # 基准

        for j in range(low, high):
            # 当前元素小于或等于 pivot
            if arr[j] <= pivot:
                i = i+1
                arr[i], arr[j] = arr[j], arr[i]  # 交换

        arr[i+1], arr[high] = arr[high], arr[i+1]
        return (i+1)

    def quick_sort(arr, low, high):
        if len(arr) == 1:
            return arr
        if low < high:
            pi = partition(arr, low, high)  # pi 是分区操作后基准的位置
            quick_sort(arr, low, pi-1)      # 对左边部分进行递归排序
            quick_sort(arr, pi+1, high)     # 对右边部分进行递归排序

    # 使用示例
    arr = [10, 7, 8, 9, 1, 5]
    n = len(arr)
    quick_sort(arr, 0, n-1)
    print("Sorted array is:", arr)
    ```

    在这个版本中，`partition` 函数用于找到基准位置并将所有小于基准的元素移动到其左侧，大于基准的元素移动到右侧。`quick_sort` 函数则负责递归地对这些子数组进行排序。这种方式避免了额外的空间开销，更适合于大型数据集。
    system: {
        "type": "tool_result",
        "id": "call_4619cdacc71e448f91c2f2",
        "name": "generate_python",
        "output": [
            {
                "type": "text",
                "text": "快速排序是一种高效的排序算法，它使用分治策略来把一个序列分为两个子序列。这里我将提供一个 Python 实现的快速排序函数。这个实现会包括递归地对数组进行划分，并在每次递归调用中选择一个“基准”元素来对数组进行分割。\n\n下面是快速排序的一个基本版本：\n\n```python\ndef quicksort(arr):\n    # 递归终止条件：如果数组长度小于等于1，则不需要排序\n    if len(arr) <= 1:\n        return arr\n    else:\n        # 选择基准值，这里我们简单地选择列表中的第一个元素\n        pivot = arr[0]\n        \n        # 所有小于基准值的元素组成的子数组\n        less = [i for i in arr[1:] if i <= pivot]\n        \n        # 所有大于基准值的元素组成的子数组\n        greater = [i for i in arr[1:] if i > pivot]\n\n        # 递归地对左右两边的子数组进行快速排序，然后与基准值合并\n        return quicksort(less) + [pivot] + quicksort(greater)\n\n# 示例\narr = [3, 6, 8, 10, 1, 2, 1]\nsorted_arr = quicksort(arr)\nprint(sorted_arr)\n```\n\n这段代码定义了一个 `quicksort` 函数，该函数接受一个列表 `arr` 作为输入并返回一个新的已排序列表。这里使用了列表推导式来构建小于和大于基准值的元素列表。这种方法虽然简洁易懂，但在处理非常大的数据集时可能不是最优解，因为它涉及到创建新的列表，这可能会消耗较多内存。\n\n如果你需要更高效的空间利用或者想要了解如何在原地修改数组以减少空间复杂度，可以考虑使用另一种方式实现快速排序，例如通过交换元素而不是创建新列表。下面是一个原地排序的例子：\n\n```python\ndef partition(arr, low, high):\n    i = (low-1)         # 最小元素索引\n    pivot = arr[high]   # 基准\n\n    for j in range(low, high):\n        # 当前元素小于或等于 pivot\n        if arr[j] <= pivot:\n            i = i+1\n            arr[i], arr[j] = arr[j], arr[i]  # 交换\n\n    arr[i+1], arr[high] = arr[high], arr[i+1]\n    return (i+1)\n\ndef quick_sort(arr, low, high):\n    if len(arr) == 1:\n        return arr\n    if low < high:\n        pi = partition(arr, low, high)  # pi 是分区操作后基准的位置\n        quick_sort(arr, low, pi-1)      # 对左边部分进行递归排序\n        quick_sort(arr, pi+1, high)     # 对右边部分进行递归排序\n\n# 使用示例\narr = [10, 7, 8, 9, 1, 5]\nn = len(arr)\nquick_sort(arr, 0, n-1)\nprint(\"Sorted array is:\", arr)\n```\n\n在这个版本中，`partition` 函数用于找到基准位置并将所有小于基准的元素移动到其左侧，大于基准的元素移动到右侧。`quick_sort` 函数则负责递归地对这些子数组进行排序。这种方式避免了额外的空间开销，更适合于大型数据集。"
            }
        ]
    }
    Router: 这里是快速排序算法的 Python 实现，包括了两个版本：

    - 第一个版本使用了简洁的列表推导式来创建小于和大于基准值（pivot）的子数组。这个实现易于理解，但可能不是最节省空间的方法。
      ```python
      def quicksort(arr):
          if len(arr) <= 1:
              return arr
          else:
              pivot = arr[0]
              less = [i for i in arr[1:] if i <= pivot]
              greater = [i for i in arr[1:] if i > pivot]
              return quicksort(less) + [pivot] + quicksort(greater)
      ```

    - 第二个版本实现了原地排序，通过在原有数组上直接进行元素交换，避免了额外的空间开销。这通常更适合处理大型数据集。
      ```python
      def partition(arr, low, high):
          # ... 分区逻辑 ...
      
      def quick_sort(arr, low, high):
          # ... 快速排序逻辑 ...

      # 使用示例
      arr = [10, 7, 8, 9, 1, 5]
      n = len(arr)
      quick_sort(arr, 0, n-1)
      print("Sorted array is:", arr)
      ```

    你可以根据自己的具体需求选择合适的实现方式。如果你需要进一步的帮助或有其他问题，请告诉我！





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 59.421 seconds)


.. _sphx_glr_download_tutorial_workflow_routing.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: workflow_routing.ipynb <workflow_routing.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: workflow_routing.py <workflow_routing.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: workflow_routing.zip <workflow_routing.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
