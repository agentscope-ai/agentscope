
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorial/workflow_routing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorial_workflow_routing.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorial_workflow_routing.py:


.. _routing:

Routing
==========================
There are two ways to implement routing in AgentScope, both simple and easy to implement:

- Routing by structured output
- Routing by tool calls

.. tip:: Considering there is no unified standard/definition for agent routing, we follow the setting in `Building effective agents <https://www.anthropic.com/engineering/building-effective-agents>`_

Routing by Structured Output
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
By this way, we can directly use the structured output of the agent to determine which agent to route the message to.

Initialize a routing agent

.. GENERATED FROM PYTHON SOURCE LINES 20-83

.. code-block:: Python

    import asyncio
    import json
    import os
    from typing import Literal

    from pydantic import BaseModel, Field

    from agentscope.agent import ReActAgent
    from agentscope.formatter import DashScopeChatFormatter
    from agentscope.memory import InMemoryMemory
    from agentscope.message import Msg
    from agentscope.model import DashScopeChatModel
    from agentscope.tool import Toolkit, ToolResponse

    router = ReActAgent(
        name="Router",
        sys_prompt="You're a routing agent. Your target is to route the user query to the right follow-up task.",
        model=DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        ),
        formatter=DashScopeChatFormatter(),
    )


    # Use structured output to specify the routing task
    class RoutingChoice(BaseModel):
        your_choice: Literal[
            "Content Generation",
            "Programming",
            "Information Retrieval",
            None,
        ] = Field(
            description="Choose the right follow-up task, and choose ``None`` if the task is too simple or no suitable task",
        )
        task_description: str | None = Field(
            description="The task description",
            default=None,
        )


    async def example_router_explicit() -> None:
        """Example of explicit routing with structured output."""
        msg_user = Msg(
            "user",
            "Help me to write a poem",
            "user",
        )

        # Route the query
        msg_res = await router(
            msg_user,
            structured_model=RoutingChoice,
        )

        # The structured output is stored in the metadata field
        print("The structured output:")
        print(json.dumps(msg_res.metadata, indent=4, ensure_ascii=False))


    asyncio.run(example_router_explicit())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/work/agentscope/agentscope/src/agentscope/model/_dashscope_model.py:231: DeprecationWarning: 'required' is not supported by DashScope API. It will be converted to 'auto'.
      warnings.warn(
    Router: {
        "type": "tool_use",
        "name": "generate_response",
        "input": {
            "your_choice": "Content Generation",
            "task_description": "Help me to write a poem"
        },
        "id": "call_6080fd128791472cbef7a2"
    }
    system: {
        "type": "tool_result",
        "id": "call_6080fd128791472cbef7a2",
        "name": "generate_response",
        "output": [
            {
                "type": "text",
                "text": "Successfully generated response."
            }
        ]
    }
    Router: Sure, I can help with that! To get started, could you share a bit more about what you'd like the poem to be about? For example, do you have a specific theme, mood, or style in mind? Any particular person or moment you wish to capture? The more details you provide, the better I can tailor the poem to your vision.
    The structured output:
    {
        "your_choice": "Content Generation",
        "task_description": "Help me to write a poem"
    }




.. GENERATED FROM PYTHON SOURCE LINES 84-90

Routing by Tool Calls
~~~~~~~~~~~~~~~~~~~~~~~~~
Another way is to wrap the downstream agents into a tool function, so that the routing agent decides which tool to call based on the user query.

We first define several tool functions:


.. GENERATED FROM PYTHON SOURCE LINES 90-140

.. code-block:: Python



    async def generate_python(demand: str) -> ToolResponse:
        """Generate Python code based on the demand.

        Args:
            demand (``str``):
                The demand for the Python code.
        """
        # An example demand agent
        python_agent = ReActAgent(
            name="PythonAgent",
            sys_prompt="You're a Python expert, your target is to generate Python code based on the demand.",
            model=DashScopeChatModel(
                model_name="qwen-max",
                api_key=os.environ["DASHSCOPE_API_KEY"],
                stream=False,
            ),
            memory=InMemoryMemory(),
            formatter=DashScopeChatFormatter(),
            toolkit=Toolkit(),
        )
        msg_res = await python_agent(Msg("user", demand, "user"))

        return ToolResponse(
            content=msg_res.get_content_blocks("text"),
        )


    # Fake some other tool functions for demonstration purposes
    async def generate_poem(demand: str) -> ToolResponse:
        """Generate a poem based on the demand.

        Args:
            demand (``str``):
                The demand for the poem.
        """
        pass


    async def web_search(query: str) -> ToolResponse:
        """Search the web for the query.

        Args:
            query (``str``):
                The query to search.
        """
        pass









.. GENERATED FROM PYTHON SOURCE LINES 141-143

After that, we define a routing agent and equip it with the above tool functions.


.. GENERATED FROM PYTHON SOURCE LINES 143-177

.. code-block:: Python


    toolkit = Toolkit()
    toolkit.register_tool_function(generate_python)
    toolkit.register_tool_function(generate_poem)
    toolkit.register_tool_function(web_search)

    # Initialize the routing agent with the toolkit
    router_implicit = ReActAgent(
        name="Router",
        sys_prompt="You're a routing agent. Your target is to route the user query to the right follow-up task.",
        model=DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        ),
        formatter=DashScopeChatFormatter(),
        toolkit=toolkit,
        memory=InMemoryMemory(),
    )


    async def example_router_implicit() -> None:
        """Example of implicit routing with tool calls."""
        msg_user = Msg(
            "user",
            "Help me to generate a quick sort function in Python",
            "user",
        )

        # Route the query
        await router_implicit(msg_user)


    asyncio.run(example_router_implicit())




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Router: {
        "type": "tool_use",
        "name": "generate_python",
        "input": {
            "demand": "a quick sort function"
        },
        "id": "call_b7650b1410614bbca26ac0"
    }
    PythonAgent: Certainly! Here's a Python implementation of the Quick Sort algorithm. This version uses the Lomuto partition scheme, which is simpler to understand and implement compared to the Hoare partition scheme.

    ```python
    def quick_sort(arr):
        def _quick_sort(items, low, high):
            if low < high:
                # Partition the array and get the pivot index
                pi = partition(items, low, high)
            
                # Recursively apply quick sort to the left and right subarrays
                _quick_sort(items, low, pi - 1)
                _quick_sort(items, pi + 1, high)

        def partition(items, low, high):
            # Choose the rightmost element as the pivot
            pivot = items[high]
            i = low - 1
        
            for j in range(low, high):
                # If the current element is smaller than or equal to the pivot
                if items[j] <= pivot:
                    i += 1
                    # Swap elements at i and j
                    items[i], items[j] = items[j], items[i]
        
            # Swap the pivot element with the element at i+1
            items[i + 1], items[high] = items[high], items[i + 1]
        
            # Return the pivot index
            return i + 1

        # Initial call to the recursive quick sort function
        _quick_sort(arr, 0, len(arr) - 1)

    # Example usage:
    arr = [10, 7, 8, 9, 1, 5]
    quick_sort(arr)
    print("Sorted array:", arr)
    ```

    ### Explanation:
    1. **`quick_sort` Function**:
       - This is the main function that initializes the sorting process.
       - It calls the `_quick_sort` helper function with the initial indices `low` and `high`.

    2. **`_quick_sort` Function**:
       - This is a recursive function that sorts the array.
       - It first partitions the array and gets the pivot index.
       - Then, it recursively sorts the left and right subarrays.

    3. **`partition` Function**:
       - This function partitions the array around a pivot (the rightmost element).
       - It places all elements less than or equal to the pivot to its left and all greater elements to its right.
       - Finally, it returns the pivot index.

    ### Example Output:
    If you run the example code, the output will be:
    ```
    Sorted array: [1, 5, 7, 8, 9, 10]
    ```

    This implementation is efficient and works well for most cases. If you have any specific requirements or need further optimizations, let me know!
    system: {
        "type": "tool_result",
        "id": "call_b7650b1410614bbca26ac0",
        "name": "generate_python",
        "output": [
            {
                "type": "text",
                "text": "Certainly! Here's a Python implementation of the Quick Sort algorithm. This version uses the Lomuto partition scheme, which is simpler to understand and implement compared to the Hoare partition scheme.\n\n```python\ndef quick_sort(arr):\n    def _quick_sort(items, low, high):\n        if low < high:\n            # Partition the array and get the pivot index\n            pi = partition(items, low, high)\n            \n            # Recursively apply quick sort to the left and right subarrays\n            _quick_sort(items, low, pi - 1)\n            _quick_sort(items, pi + 1, high)\n\n    def partition(items, low, high):\n        # Choose the rightmost element as the pivot\n        pivot = items[high]\n        i = low - 1\n        \n        for j in range(low, high):\n            # If the current element is smaller than or equal to the pivot\n            if items[j] <= pivot:\n                i += 1\n                # Swap elements at i and j\n                items[i], items[j] = items[j], items[i]\n        \n        # Swap the pivot element with the element at i+1\n        items[i + 1], items[high] = items[high], items[i + 1]\n        \n        # Return the pivot index\n        return i + 1\n\n    # Initial call to the recursive quick sort function\n    _quick_sort(arr, 0, len(arr) - 1)\n\n# Example usage:\narr = [10, 7, 8, 9, 1, 5]\nquick_sort(arr)\nprint(\"Sorted array:\", arr)\n```\n\n### Explanation:\n1. **`quick_sort` Function**:\n   - This is the main function that initializes the sorting process.\n   - It calls the `_quick_sort` helper function with the initial indices `low` and `high`.\n\n2. **`_quick_sort` Function**:\n   - This is a recursive function that sorts the array.\n   - It first partitions the array and gets the pivot index.\n   - Then, it recursively sorts the left and right subarrays.\n\n3. **`partition` Function**:\n   - This function partitions the array around a pivot (the rightmost element).\n   - It places all elements less than or equal to the pivot to its left and all greater elements to its right.\n   - Finally, it returns the pivot index.\n\n### Example Output:\nIf you run the example code, the output will be:\n```\nSorted array: [1, 5, 7, 8, 9, 10]\n```\n\nThis implementation is efficient and works well for most cases. If you have any specific requirements or need further optimizations, let me know!"
            }
        ]
    }
    Router: The Python implementation of the Quick Sort algorithm using the Lomuto partition scheme has been generated. Here's a brief overview of the code:

    - The `quick_sort` function is the main function that you will call to sort an array.
    - It internally uses a `_quick_sort` helper function, which is recursive and sorts the subarrays.
    - The `partition` function is used to organize elements around a pivot, which is chosen as the rightmost element in this case.

    To use the quick sort function, simply pass your list of numbers to it, as shown in the example usage. The output will be a sorted array.

    If you need further customization or have any questions, feel free to ask!
    ![](https://web.sfc.keio.ac.jp/~hara/quick-sort.png)

    Here's the code for you to use:

    ```python
    def quick_sort(arr):
        def _quick_sort(items, low, high):
            if low < high:
                pi = partition(items, low, high)
                _quick_sort(items, low, pi - 1)
                _quick_sort(items, pi + 1, high)

        def partition(items, low, high):
            pivot = items[high]
            i = low - 1
            for j in range(low, high):
                if items[j] <= pivot:
                    i += 1
                    items[i], items[j] = items[j], items[i]
            items[i + 1], items[high] = items[high], items[i + 1]
            return i + 1

        _quick_sort(arr, 0, len(arr) - 1)

    # Example usage:
    arr = [10, 7, 8, 9, 1, 5]
    quick_sort(arr)
    print("Sorted array:", arr)
    ```

    You can run this code with your own list of numbers to sort them.





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 57.806 seconds)


.. _sphx_glr_download_tutorial_workflow_routing.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: workflow_routing.ipynb <workflow_routing.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: workflow_routing.py <workflow_routing.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: workflow_routing.zip <workflow_routing.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
