
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorial/task_pipeline.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorial_task_pipeline.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorial_task_pipeline.py:


.. _pipeline:

Pipeline
========================

For multi-agent orchestration, AgentScope provides the ``agentscope.pipeline`` module
as syntax sugar for chaining agents together, including

- **MsgHub**: a message hub for broadcasting messages among multiple agents
- **sequential_pipeline** and **SequentialPipeline**: a functional and class-based implementation that chains agents in a sequential manner
- **fanout_pipeline** and **FanoutPipeline**: a functional and class-based implementation that distributes the same input to multiple agents
- **stream_printing_messages**: a utility function that convert the printing messages from agent(s) into an async generator

.. GENERATED FROM PYTHON SOURCE LINES 17-27

.. code-block:: Python


    import os, asyncio

    from agentscope.formatter import DashScopeMultiAgentFormatter
    from agentscope.message import Msg
    from agentscope.model import DashScopeChatModel
    from agentscope.agent import ReActAgent
    from agentscope.pipeline import MsgHub, stream_printing_messages









.. GENERATED FROM PYTHON SOURCE LINES 28-40

Broadcasting with MsgHub
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``MsgHub`` class is an **async context manager**, receiving a list of agents as its participants.
When one participant generates a replying message, all other participants will receive this message by calling their ``observe`` method.

That means within a ``MsgHub`` context, developers don't need to manually send a replying message from one agent to another.
The broadcasting is automatically handled.

Here we create four agents: Alice, Bob, Charlie and David.
Then we start a meeting with Alice, Bob and Charlie by introducing themselves.
Note David is not included in this meeting.

.. GENERATED FROM PYTHON SOURCE LINES 40-60

.. code-block:: Python



    def create_agent(name: str, age: int, career: str) -> ReActAgent:
        """Create agent object by the given information."""
        return ReActAgent(
            name=name,
            sys_prompt=f"You're {name}, a {age}-year-old {career}",
            model=DashScopeChatModel(
                model_name="qwen-max",
                api_key=os.environ["DASHSCOPE_API_KEY"],
            ),
            formatter=DashScopeMultiAgentFormatter(),
        )


    alice = create_agent("Alice", 50, "teacher")
    bob = create_agent("Bob", 35, "engineer")
    charlie = create_agent("Charlie", 28, "designer")
    david = create_agent("David", 30, "developer")








.. GENERATED FROM PYTHON SOURCE LINES 61-65

Then we start a meeting and let them introduce themselves without manual message passing:

.. hint:: The message in ``announcement`` will be broadcasted to all participants when entering the ``MsgHub`` context.


.. GENERATED FROM PYTHON SOURCE LINES 65-87

.. code-block:: Python



    async def example_broadcast_message():
        """Example of broadcasting messages with MsgHub."""

        # Create a message hub
        async with MsgHub(
            participants=[alice, bob, charlie],
            announcement=Msg(
                "user",
                "Now introduce yourself in one sentence, including your name, age and career.",
                "user",
            ),
        ) as hub:
            # Group chat without manual message passing
            await alice()
            await bob()
            await charlie()


    asyncio.run(example_broadcast_message())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Alice: Hello, I'm Alice, a 50-year-old teacher with a passion for education and a wealth of experience in the classroom.
    Bob: Hello, I'm Bob, a 35-year-old engineer with a knack for solving complex problems and designing innovative solutions.
    Charlie: Hello, I'm Charlie, a 28-year-old designer with a creative flair for bringing ideas to life through visual and interactive design.




.. GENERATED FROM PYTHON SOURCE LINES 88-90

Now let's check if Bob, Charlie and David received Alice's message.


.. GENERATED FROM PYTHON SOURCE LINES 90-107

.. code-block:: Python



    async def check_broadcast_message():
        """Check if the messages are broadcast correctly."""
        user_msg = Msg(
            "user",
            "Do you know who's Alice, and what she does? Answer me briefly.",
            "user",
        )

        await bob(user_msg)
        await charlie(user_msg)
        await david(user_msg)


    asyncio.run(check_broadcast_message())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Bob: Alice is a 50-year-old teacher who is passionate about education and has extensive experience in the classroom.
    Charlie: Alice is a 50-year-old teacher who is passionate about education and has a lot of experience in the classroom.
    David: I don't have specific information about who Alice is or what she does, as it can refer to many different people. Could you provide more context or details so I can give you the correct information?




.. GENERATED FROM PYTHON SOURCE LINES 108-176

Now we observe that Bob and Charlie know Alice and her profession, while David has no idea
about Alice since he is not included in the ``MsgHub`` context.


Dynamic Participant Management
---------------------------------------
Additionally, ``MsgHub`` supports to dynamically manage participants by the following methods:

- ``add``: add one or multiple agents as new participants
- ``delete``: remove one or multiple agents from participants, and they will no longer receive broadcasted messages
- ``broadcast``: broadcast a message to all current participants

.. note:: The newly added participants will not receive the previous messages.

.. code-block:: python

      async with MsgHub(participants=[alice]) as hub:
          # Add new participants
          hub.add(david)

          # Remove participants
          hub.delete(alice)

          # Broadcast to all current participants
          await hub.broadcast(
              Msg("system", "Now we begin to ...", "system"),
          )


Pipeline
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Pipeline serves as a syntax sugar for multi-agent orchestration.

Currently, AgentScope provides three main pipeline implementations:

1. **Sequential Pipeline**: Execute agents one by one in a predefined order
2. **Fanout Pipeline**: Distribute the same input to multiple agents and collect their responses
3. **Stream Printing Messages**: Convert the printing messages from an agent into an async generator

Sequential Pipeline
------------------------
The sequential pipeline executes agents one by one, where the output of the previous agent
becomes the input of the next agent.

For example, the two following code snippets are equivalent:


.. code-block:: python
    :caption: Code snippet 1: Manually call agents one by one

    msg = None
    msg = await alice(msg)
    msg = await bob(msg)
    msg = await charlie(msg)
    msg = await david(msg)


.. code-block:: python
    :caption: Code snippet 2: Use sequential pipeline

    from agentscope.pipeline import sequential_pipeline
    msg = await sequential_pipeline(
        # List of agents to be executed in order
        agents=[alice, bob, charlie, david],
        # The first input message, can be None
        msg=None
    )


.. GENERATED FROM PYTHON SOURCE LINES 178-231

Fanout Pipeline
------------------------
The fanout pipeline distributes the same input message to multiple agents simultaneously and collects all their responses. This is useful when you want to gather different perspectives or expertise on the same topic.

For example, the two following code snippets are equivalent:


.. code-block:: python
    :caption: Code snippet 3: Manually call agents one by one

    from copy import deepcopy

    msgs = []
    msg = None
    for agent in [alice, bob, charlie, david]:
        msgs.append(await agent(deepcopy(msg)))


.. code-block:: python
    :caption: Code snippet 4: Use fanout pipeline

    from agentscope.pipeline import fanout_pipeline
    msgs = await fanout_pipeline(
        # List of agents to be executed in order
        agents=[alice, bob, charlie, david],
        # The first input message, can be None
        msg=None,
        enable_gather=False,
    )

.. note::
    The ``enable_gather`` parameter controls the execution mode of the fanout pipeline:

    - ``enable_gather=True`` (default): Executes all agents **concurrently** using ``asyncio.gather()``. This provides better performance for I/O-bound operations like API calls, as agents run in parallel.
    - ``enable_gather=False``: Executes agents **sequentially** one by one. This is useful when you need deterministic execution order or want to avoid overwhelming external services with concurrent requests.

    Choose concurrent execution for better performance, or sequential execution for predictable ordering and resource control.

.. tip::
    By combining ``MsgHub`` and ``sequential_pipeline`` or ``fanout_pipeline``, you can create more complex workflows very easily.


Stream Printing Messages
-------------------------------------
The ``stream_printing_messages`` function converts the printing messages from agent(s) into an async generator.
It will help you to obtain the intermediate messages from the agent(s) in a streaming way.

It accepts a list of agents and a coroutine task, then returns an async generator that yields tuples of ``(Msg, bool)``,
containing the printing message during execution of the coroutine task.

Note the messages with the same ``id`` are considered as the same message, and the ``last`` flag indicates whether it's the last chunk of this message.

Taking the following code snippet as an example:

.. GENERATED FROM PYTHON SOURCE LINES 231-254

.. code-block:: Python



    async def run_example_pipeline() -> None:
        """Run an example of streaming printing messages."""
        agent = create_agent("Alice", 20, "student")

        # We disable the terminal printing to avoid messy outputs
        agent.set_console_output_enabled(False)

        async for msg, last in stream_printing_messages(
            agents=[agent],
            coroutine_task=agent(
                Msg("user", "Hello, who are you?", "user"),
            ),
        ):
            print(msg, last)
            if last:
                print()


    asyncio.run(run_example_pipeline())






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Msg(id='DAv6vk4J3a3phRctXQn5um', name='Alice', content=[{'type': 'text', 'text': 'Hello'}], role='assistant', metadata=None, timestamp='2025-10-31 02:53:43.405', invocation_id='None') False
    Msg(id='DAv6vk4J3a3phRctXQn5um', name='Alice', content=[{'type': 'text', 'text': "Hello! I'm"}], role='assistant', metadata=None, timestamp='2025-10-31 02:53:43.405', invocation_id='None') False
    Msg(id='DAv6vk4J3a3phRctXQn5um', name='Alice', content=[{'type': 'text', 'text': "Hello! I'm Alice, a"}], role='assistant', metadata=None, timestamp='2025-10-31 02:53:43.405', invocation_id='None') False
    Msg(id='DAv6vk4J3a3phRctXQn5um', name='Alice', content=[{'type': 'text', 'text': "Hello! I'm Alice, a 20"}], role='assistant', metadata=None, timestamp='2025-10-31 02:53:43.405', invocation_id='None') False
    Msg(id='DAv6vk4J3a3phRctXQn5um', name='Alice', content=[{'type': 'text', 'text': "Hello! I'm Alice, a 20-year-old student. Nice"}], role='assistant', metadata=None, timestamp='2025-10-31 02:53:43.405', invocation_id='None') False
    Msg(id='DAv6vk4J3a3phRctXQn5um', name='Alice', content=[{'type': 'text', 'text': "Hello! I'm Alice, a 20-year-old student. Nice to meet you! How can"}], role='assistant', metadata=None, timestamp='2025-10-31 02:53:43.405', invocation_id='None') False
    Msg(id='DAv6vk4J3a3phRctXQn5um', name='Alice', content=[{'type': 'text', 'text': "Hello! I'm Alice, a 20-year-old student. Nice to meet you! How can I assist you today?"}], role='assistant', metadata=None, timestamp='2025-10-31 02:53:43.405', invocation_id='None') False
    Msg(id='DAv6vk4J3a3phRctXQn5um', name='Alice', content=[{'type': 'text', 'text': "Hello! I'm Alice, a 20-year-old student. Nice to meet you! How can I assist you today?"}], role='assistant', metadata=None, timestamp='2025-10-31 02:53:43.405', invocation_id='None') False
    Msg(id='DAv6vk4J3a3phRctXQn5um', name='Alice', content=[{'type': 'text', 'text': "Hello! I'm Alice, a 20-year-old student. Nice to meet you! How can I assist you today?"}], role='assistant', metadata=None, timestamp='2025-10-31 02:53:43.405', invocation_id='None') True





.. GENERATED FROM PYTHON SOURCE LINES 255-289

Advanced Pipeline Features
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Additionally, for reusability, we also provide a class-based implementation:

.. code-block:: python
    :caption: Using SequentialPipeline class

    from agentscope.pipeline import SequentialPipeline

    # Create a pipeline object
    pipeline = SequentialPipeline(agents=[alice, bob, charlie, david])

    # Call the pipeline
    msg = await pipeline(msg=None)

    # Reuse the pipeline with different input
    msg = await pipeline(msg=Msg("user", "Hello!", "user"))


.. code-block:: python
    :caption: Using FanoutPipeline class

    from agentscope.pipeline import FanoutPipeline

    # Create a pipeline object
    pipeline = FanoutPipeline(agents=[alice, bob, charlie, david])

    # Call the pipeline
    msgs = await pipeline(msg=None)

    # Reuse the pipeline with different input
    msgs = await pipeline(msg=Msg("user", "Hello!", "user"))



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 15.359 seconds)


.. _sphx_glr_download_tutorial_task_pipeline.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: task_pipeline.ipynb <task_pipeline.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: task_pipeline.py <task_pipeline.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: task_pipeline.zip <task_pipeline.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
