
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorial/task_model.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorial_task_model.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorial_task_model.py:


.. _model:

Model
====================

In this tutorial, we introduce the model APIs integrated in AgentScope, how to use them and how to integrate new model APIs.
The supported model APIs and providers include:

.. list-table::
    :header-rows: 1

    * - API
      - Class
      - Compatible
      - Streaming
      - Tools
      - Vision
      - Reasoning
    * - OpenAI
      - ``OpenAIChatModel``
      - vLLM, DeepSeek
      - ✅
      - ✅
      - ✅
      - ✅
    * - DashScope
      - ``DashScopeChatModel``
      -
      - ✅
      - ✅
      - ✅
      - ✅
    * - Anthropic
      - ``AnthropicChatModel``
      -
      - ✅
      - ✅
      - ✅
      - ✅
    * - Gemini
      - ``GeminiChatModel``
      -
      - ✅
      - ✅
      - ✅
      - ✅
    * - Ollama
      - ``OllamaChatModel``
      -
      - ✅
      - ✅
      - ✅
      - ✅

.. note:: When using vLLM, you need to configure the appropriate tool calling parameters for different models during deployment, such as ``--enable-auto-tool-choice``, ``--tool-call-parser``, etc. For more details, refer to the `official vLLM documentation <https://docs.vllm.ai/en/latest/features/tool_calling.html>`_.

To provide unified model interfaces, the above model classes has the following common methods:

- The first three arguments of the ``__call__`` method are ``messages`` , ``tools`` and ``tool_choice``, representing the input messages, JSON schema of tool functions, and tool selection mode, respectively.
- The return type are either a ``ChatResponse`` instance or an async generator of ``ChatResponse`` in streaming mode.

.. note:: Different model APIs differ in the input message format, refer to :ref:`prompt` for more details.

The ``ChatResponse`` instance contains the generated thinking/text/tool use content, identity, created time and usage information.

.. GENERATED FROM PYTHON SOURCE LINES 68-93

.. code-block:: Python

    import asyncio
    import json
    import os

    from agentscope.message import TextBlock, ToolUseBlock, ThinkingBlock, Msg
    from agentscope.model import ChatResponse, DashScopeChatModel

    response = ChatResponse(
        content=[
            ThinkingBlock(
                type="thinking",
                thinking="I should search for AgentScope on Google.",
            ),
            TextBlock(type="text", text="I'll search for AgentScope on Google."),
            ToolUseBlock(
                type="tool_use",
                id="642n298gjna",
                name="google_search",
                input={"query": "AgentScope?"},
            ),
        ],
    )

    print(response)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ChatResponse(content=[{'type': 'thinking', 'thinking': 'I should search for AgentScope on Google.'}, {'type': 'text', 'text': "I'll search for AgentScope on Google."}, {'type': 'tool_use', 'id': '642n298gjna', 'name': 'google_search', 'input': {'query': 'AgentScope?'}}], id='2025-09-08 03:32:25.494_a435a1', created_at='2025-09-08 03:32:25.494', type='chat', usage=None, metadata=None)




.. GENERATED FROM PYTHON SOURCE LINES 94-95

Taking ``DashScopeChatModel`` as an example, we can use it to create a chat model instance and call it with messages and tools:

.. GENERATED FROM PYTHON SOURCE LINES 95-120

.. code-block:: Python



    async def example_model_call() -> None:
        """An example of using the DashScopeChatModel."""
        model = DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        )

        res = await model(
            messages=[
                {"role": "user", "content": "Hi!"},
            ],
        )

        # You can directly create a ``Msg`` object with the response content
        msg_res = Msg("Friday", res.content, "assistant")

        print("The response:", res)
        print("The response as Msg:", msg_res)


    asyncio.run(example_model_call())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The response: ChatResponse(content=[{'type': 'text', 'text': 'Hello! How can I assist you today?'}], id='2025-09-08 03:32:26.743_92f3c4', created_at='2025-09-08 03:32:26.743', type='chat', usage=ChatUsage(input_tokens=10, output_tokens=9, time=1.248483, type='chat'), metadata=None)
    The response as Msg: Msg(id='Rwmrz6FJQhN2aFrBU7reku', name='Friday', content=[{'type': 'text', 'text': 'Hello! How can I assist you today?'}], role='assistant', metadata=None, timestamp='2025-09-08 03:32:26.743', invocation_id='None')




.. GENERATED FROM PYTHON SOURCE LINES 121-128

Streaming
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To enable streaming model, set the ``stream`` parameter in the model constructor to ``True``.
When streaming is enabled, the ``__call__`` method will return an **async generator** that yields ``ChatResponse`` instances as they are generated by the model.

.. note:: The streaming mode in AgentScope is designed to be **cumulative**, meaning the content in each chunk contains all the previous content plus the newly generated content.


.. GENERATED FROM PYTHON SOURCE LINES 128-158

.. code-block:: Python



    async def example_streaming() -> None:
        """An example of using the streaming model."""
        model = DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=True,
        )

        generator = await model(
            messages=[
                {
                    "role": "user",
                    "content": "Count from 1 to 20, and just report the number without any other information.",
                },
            ],
        )
        print("The type of the response:", type(generator))

        i = 0
        async for chunk in generator:
            print(f"Chunk {i}")
            print(f"\ttype: {type(chunk.content)}")
            print(f"\t{chunk}\n")
            i += 1


    asyncio.run(example_streaming())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The type of the response: <class 'async_generator'>
    Chunk 0
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1'}], id='2025-09-08 03:32:27.734_d691a9', created_at='2025-09-08 03:32:27.734', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=1, time=0.98914, type='chat'), metadata=None)

    Chunk 1
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n'}], id='2025-09-08 03:32:27.794_415b8b', created_at='2025-09-08 03:32:27.794', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=2, time=1.049283, type='chat'), metadata=None)

    Chunk 2
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2'}], id='2025-09-08 03:32:27.857_52abde', created_at='2025-09-08 03:32:27.857', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=3, time=1.111748, type='chat'), metadata=None)

    Chunk 3
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n'}], id='2025-09-08 03:32:27.918_bb767f', created_at='2025-09-08 03:32:27.918', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=4, time=1.172831, type='chat'), metadata=None)

    Chunk 4
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n'}], id='2025-09-08 03:32:28.333_147300', created_at='2025-09-08 03:32:28.333', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=8, time=1.588078, type='chat'), metadata=None)

    Chunk 5
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n'}], id='2025-09-08 03:32:28.622_6775b8', created_at='2025-09-08 03:32:28.622', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=12, time=1.877015, type='chat'), metadata=None)

    Chunk 6
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n'}], id='2025-09-08 03:32:29.197_b01488', created_at='2025-09-08 03:32:29.197', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=16, time=2.451926, type='chat'), metadata=None)

    Chunk 7
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10'}], id='2025-09-08 03:32:29.462_530dd3', created_at='2025-09-08 03:32:29.462', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=20, time=2.716998, type='chat'), metadata=None)

    Chunk 8
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n'}], id='2025-09-08 03:32:29.682_976ba7', created_at='2025-09-08 03:32:29.682', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=24, time=2.936992, type='chat'), metadata=None)

    Chunk 9
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n1'}], id='2025-09-08 03:32:29.920_7fe06f', created_at='2025-09-08 03:32:29.920', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=28, time=3.175073, type='chat'), metadata=None)

    Chunk 10
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14'}], id='2025-09-08 03:32:30.160_0fa0d3', created_at='2025-09-08 03:32:30.160', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=32, time=3.414968, type='chat'), metadata=None)

    Chunk 11
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n'}], id='2025-09-08 03:32:30.420_a5e521', created_at='2025-09-08 03:32:30.420', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=36, time=3.675009, type='chat'), metadata=None)

    Chunk 12
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n1'}], id='2025-09-08 03:32:30.687_36b912', created_at='2025-09-08 03:32:30.687', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=40, time=3.942064, type='chat'), metadata=None)

    Chunk 13
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18'}], id='2025-09-08 03:32:30.895_ef9128', created_at='2025-09-08 03:32:30.895', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=44, time=4.15006, type='chat'), metadata=None)

    Chunk 14
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n'}], id='2025-09-08 03:32:31.153_4417ca', created_at='2025-09-08 03:32:31.153', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=48, time=4.408305, type='chat'), metadata=None)

    Chunk 15
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20'}], id='2025-09-08 03:32:31.341_b15c2e', created_at='2025-09-08 03:32:31.341', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=50, time=4.595722, type='chat'), metadata=None)

    Chunk 16
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20'}], id='2025-09-08 03:32:31.361_0568e7', created_at='2025-09-08 03:32:31.361', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=50, time=4.615841, type='chat'), metadata=None)





.. GENERATED FROM PYTHON SOURCE LINES 159-163

Reasoning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
AgentScope supports reasoning models by providing the ``ThinkingBlock``.


.. GENERATED FROM PYTHON SOURCE LINES 163-188

.. code-block:: Python



    async def example_reasoning() -> None:
        """An example of using the reasoning model."""
        model = DashScopeChatModel(
            model_name="qwen-turbo",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            enable_thinking=True,
        )

        res = await model(
            messages=[
                {"role": "user", "content": "Who am I?"},
            ],
        )

        last_chunk = None
        async for chunk in res:
            last_chunk = chunk
        print("The final response:")
        print(last_chunk)


    asyncio.run(example_reasoning())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The final response:
    ChatResponse(content=[{'type': 'thinking', 'thinking': 'Okay, the user asked "Who am I?" So, first, I need to figure out what they\'re really asking. They might be looking for a philosophical answer about their identity, or maybe they\'re confused about their own sense of self. Alternatively, they could be referring to my identity as an AI.\n\nI should start by acknowledging that the question is profound and has been explored in various fields like philosophy, psychology, and religion. It\'s important to mention different perspectives. For example, in philosophy, thinkers like Descartes and Sartre have discussed self-identity. In psychology, there\'s the concept of self-concept and self-awareness. Religions often have their own take on the self, like the idea of the soul or the ego.\n\nI should also consider the user\'s possible intent. If they\'re feeling lost or searching for meaning, offering support and suggesting self-reflection could be helpful. Maybe they\'re looking for guidance on how to understand themselves better. It\'s important to keep the response open-ended and not too technical, so it\'s accessible.\n\nAdditionally, since I\'m an AI, I should clarify that while I can\'t know their personal identity, I can provide information and perspectives. But I need to make sure not to overstep and offer advice that\'s beyond my capabilities. Encouraging them to reflect on their experiences, values, and relationships might be a good approach.\n\nI should structure the answer to cover different angles: philosophical, psychological, and spiritual, then offer practical steps for self-exploration. Keep the tone empathetic and supportive. Avoid jargon, keep it conversational. Make sure to invite them to share more if they want a deeper discussion.\n'}, {'type': 'text', 'text': 'The question "Who am I?" is one of the most profound and timeless inquiries humans have grappled with. It touches on identity, purpose, and the nature of existence. Here’s a reflective exploration of the question from different perspectives:\n\n### 1. **Philosophical Perspective**  \n   - **Self as a Construct**: Thinkers like Descartes ("I think, therefore I am") suggest that identity is tied to consciousness. Others, like Buddhist philosophy, argue that the "self" is an illusion—a collection of impermanent thoughts, feelings, and experiences.  \n   - **Existentialism**: Philosophers like Sartre emphasized that we define ourselves through choices and actions. "Existence precedes essence," meaning we create our identity through lived experiences.  \n\n### 2. **Psychological Perspective**  \n   - **Self-Concept**: Your identity is shaped by memories, beliefs, values, and relationships. Psychologists like Carl Jung spoke of the "self" as a dynamic interplay between the conscious and unconscious mind.  \n   - **Narrative Identity**: Many see the self as a story we tell ourselves—shaped by experiences, goals, and how we interpret the world.  \n\n### 3. **Spiritual/Religious Perspective**  \n   - **Beyond the Ego**: Many traditions (e.g., Hinduism, Buddhism, Christianity) suggest the "true self" transcends the ego or physical body. For example, the Upanishads speak of the "Atman" (true self) as eternal and interconnected with the universe.  \n   - **Connection to Something Greater**: Some find identity in relationships, service, or a higher purpose (e.g., "I am a parent," "I am a creator," or "I am part of something larger").  \n\n### 4. **Practical Reflection**  \n   - **Ask Yourself**:  \n     - What values guide my decisions?  \n     - What brings me joy or meaning?  \n     - How do I see myself in relation to others and the world?  \n   - **Embrace Fluidity**: Identity isn’t static. It evolves with time, experiences, and growth.  \n\n### 5. **A Simple Truth**  \n   At the core, "you" are the sum of your experiences, thoughts, and the choices you make. You are both unique and connected to all of humanity. The journey of self-discovery is ongoing, and there’s no single "answer"—only the process of exploring, questioning, and growing.  \n\nIf this feels abstract, consider sharing more about what you’re seeking, and I can help unpack it further. 🌱'}], id='2025-09-08 03:32:45.872_8cc67e', created_at='2025-09-08 03:32:45.872', type='chat', usage=ChatUsage(input_tokens=12, output_tokens=888, time=14.506461, type='chat'), metadata=None)




.. GENERATED FROM PYTHON SOURCE LINES 189-197

Tools API
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Different model providers differ in their tools APIs, e.g. the tools JSON schema, the tool call/response format.
To provide a unified interface, AgentScope solves the problem by:

- Providing unified tool call block :ref:`ToolUseBlock <tool-block>` and tool response block :ref:`ToolResultBlock <tool-block>`, respectively.
- Providing a unified tools interface in the ``__call__`` method of the model classes, that accepts a list of tools JSON schemas as follows:


.. GENERATED FROM PYTHON SOURCE LINES 197-218

.. code-block:: Python


    json_schemas = [
        {
            "type": "function",
            "function": {
                "name": "google_search",
                "description": "Search for a query on Google.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "The search query.",
                        },
                    },
                    "required": ["query"],
                },
            },
        },
    ]








.. GENERATED FROM PYTHON SOURCE LINES 219-224

Further Reading
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- :ref:`message`
- :ref:`prompt`



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 20.384 seconds)


.. _sphx_glr_download_tutorial_task_model.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: task_model.ipynb <task_model.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: task_model.py <task_model.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: task_model.zip <task_model.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
