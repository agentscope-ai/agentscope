{
  "version": 3,
  "sources": ["../../../../node_modules/@a2a-js/sdk/dist/chunk-3QDLXHKS.js", "../../../../node_modules/@a2a-js/sdk/dist/chunk-ZX6KNMCP.js", "../../../../node_modules/@a2a-js/sdk/dist/client/index.js"],
  "sourcesContent": ["// src/constants.ts\nvar AGENT_CARD_PATH = \".well-known/agent-card.json\";\nvar HTTP_EXTENSION_HEADER = \"X-A2A-Extensions\";\n\nexport {\n  AGENT_CARD_PATH,\n  HTTP_EXTENSION_HEADER\n};\n", "// src/extensions.ts\nvar Extensions = {\n  /**\n   * Creates new {@link Extensions} from `current` and `additional`.\n   * If `current` already contains `additional` it is returned unmodified.\n   */\n  createFrom: (current, additional) => {\n    if (current?.includes(additional)) {\n      return current;\n    }\n    return [...current ?? [], additional];\n  },\n  /**\n   * Creates {@link Extensions} from comma separated extensions identifiers as per\n   * https://a2a-protocol.org/latest/specification/#326-service-parameters.\n   * Parses the output of `toServiceParameter`.\n   */\n  parseServiceParameter: (value) => {\n    if (!value) {\n      return [];\n    }\n    const unique = new Set(\n      value.split(\",\").map((ext) => ext.trim()).filter((ext) => ext.length > 0)\n    );\n    return Array.from(unique);\n  },\n  /**\n   * Converts {@link Extensions} to comma separated extensions identifiers as per\n   * https://a2a-protocol.org/latest/specification/#326-service-parameters.\n   */\n  toServiceParameter: (value) => {\n    return value.join(\",\");\n  }\n};\n\nexport {\n  Extensions\n};\n", "import {\n  AGENT_CARD_PATH,\n  HTTP_EXTENSION_HEADER\n} from \"../chunk-3QDLXHKS.js\";\nimport {\n  Extensions\n} from \"../chunk-ZX6KNMCP.js\";\n\n// src/errors.ts\nvar TaskNotFoundError = class extends Error {\n  constructor(message) {\n    super(message ?? \"Task not found\");\n    this.name = \"TaskNotFoundError\";\n  }\n};\nvar TaskNotCancelableError = class extends Error {\n  constructor(message) {\n    super(message ?? \"Task cannot be canceled\");\n    this.name = \"TaskNotCancelableError\";\n  }\n};\nvar PushNotificationNotSupportedError = class extends Error {\n  constructor(message) {\n    super(message ?? \"Push Notification is not supported\");\n    this.name = \"PushNotificationNotSupportedError\";\n  }\n};\nvar UnsupportedOperationError = class extends Error {\n  constructor(message) {\n    super(message ?? \"This operation is not supported\");\n    this.name = \"UnsupportedOperationError\";\n  }\n};\nvar ContentTypeNotSupportedError = class extends Error {\n  constructor(message) {\n    super(message ?? \"Incompatible content types\");\n    this.name = \"ContentTypeNotSupportedError\";\n  }\n};\nvar InvalidAgentResponseError = class extends Error {\n  constructor(message) {\n    super(message ?? \"Invalid agent response type\");\n    this.name = \"InvalidAgentResponseError\";\n  }\n};\nvar AuthenticatedExtendedCardNotConfiguredError = class extends Error {\n  constructor(message) {\n    super(message ?? \"Authenticated Extended Card not configured\");\n    this.name = \"AuthenticatedExtendedCardNotConfiguredError\";\n  }\n};\n\n// src/client/transports/json_rpc_transport.ts\nvar JsonRpcTransport = class _JsonRpcTransport {\n  customFetchImpl;\n  endpoint;\n  requestIdCounter = 1;\n  constructor(options) {\n    this.endpoint = options.endpoint;\n    this.customFetchImpl = options.fetchImpl;\n  }\n  async getExtendedAgentCard(options, idOverride) {\n    const rpcResponse = await this._sendRpcRequest(\"agent/getAuthenticatedExtendedCard\", void 0, idOverride, options);\n    return rpcResponse.result;\n  }\n  async sendMessage(params, options, idOverride) {\n    const rpcResponse = await this._sendRpcRequest(\n      \"message/send\",\n      params,\n      idOverride,\n      options\n    );\n    return rpcResponse.result;\n  }\n  async *sendMessageStream(params, options) {\n    yield* this._sendStreamingRequest(\"message/stream\", params, options);\n  }\n  async setTaskPushNotificationConfig(params, options, idOverride) {\n    const rpcResponse = await this._sendRpcRequest(\"tasks/pushNotificationConfig/set\", params, idOverride, options);\n    return rpcResponse.result;\n  }\n  async getTaskPushNotificationConfig(params, options, idOverride) {\n    const rpcResponse = await this._sendRpcRequest(\"tasks/pushNotificationConfig/get\", params, idOverride, options);\n    return rpcResponse.result;\n  }\n  async listTaskPushNotificationConfig(params, options, idOverride) {\n    const rpcResponse = await this._sendRpcRequest(\"tasks/pushNotificationConfig/list\", params, idOverride, options);\n    return rpcResponse.result;\n  }\n  async deleteTaskPushNotificationConfig(params, options, idOverride) {\n    await this._sendRpcRequest(\"tasks/pushNotificationConfig/delete\", params, idOverride, options);\n  }\n  async getTask(params, options, idOverride) {\n    const rpcResponse = await this._sendRpcRequest(\n      \"tasks/get\",\n      params,\n      idOverride,\n      options\n    );\n    return rpcResponse.result;\n  }\n  async cancelTask(params, options, idOverride) {\n    const rpcResponse = await this._sendRpcRequest(\n      \"tasks/cancel\",\n      params,\n      idOverride,\n      options\n    );\n    return rpcResponse.result;\n  }\n  async *resubscribeTask(params, options) {\n    yield* this._sendStreamingRequest(\"tasks/resubscribe\", params, options);\n  }\n  async callExtensionMethod(method, params, idOverride, options) {\n    return await this._sendRpcRequest(\n      method,\n      params,\n      idOverride,\n      options\n    );\n  }\n  _fetch(...args) {\n    if (this.customFetchImpl) {\n      return this.customFetchImpl(...args);\n    }\n    if (typeof fetch === \"function\") {\n      return fetch(...args);\n    }\n    throw new Error(\n      \"A `fetch` implementation was not provided and is not available in the global scope. Please provide a `fetchImpl` in the A2ATransportOptions. \"\n    );\n  }\n  async _sendRpcRequest(method, params, idOverride, options) {\n    const requestId = idOverride ?? this.requestIdCounter++;\n    const rpcRequest = {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: requestId\n    };\n    const httpResponse = await this._fetchRpc(rpcRequest, \"application/json\", options);\n    if (!httpResponse.ok) {\n      let errorBodyText = \"(empty or non-JSON response)\";\n      let errorJson;\n      try {\n        errorBodyText = await httpResponse.text();\n        errorJson = JSON.parse(errorBodyText);\n      } catch (e) {\n        throw new Error(\n          `HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`,\n          { cause: e }\n        );\n      }\n      if (errorJson.jsonrpc && errorJson.error) {\n        throw _JsonRpcTransport.mapToError(errorJson);\n      } else {\n        throw new Error(\n          `HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`\n        );\n      }\n    }\n    const rpcResponse = await httpResponse.json();\n    if (rpcResponse.id !== requestId) {\n      console.error(\n        `CRITICAL: RPC response ID mismatch for method ${method}. Expected ${requestId}, got ${rpcResponse.id}.`\n      );\n    }\n    if (\"error\" in rpcResponse) {\n      throw _JsonRpcTransport.mapToError(rpcResponse);\n    }\n    return rpcResponse;\n  }\n  async _fetchRpc(rpcRequest, acceptHeader = \"application/json\", options) {\n    const requestInit = {\n      method: \"POST\",\n      headers: {\n        ...options?.serviceParameters,\n        \"Content-Type\": \"application/json\",\n        Accept: acceptHeader\n      },\n      body: JSON.stringify(rpcRequest),\n      signal: options?.signal\n    };\n    return this._fetch(this.endpoint, requestInit);\n  }\n  async *_sendStreamingRequest(method, params, options) {\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: clientRequestId\n    };\n    const response = await this._fetchRpc(rpcRequest, \"text/event-stream\", options);\n    if (!response.ok) {\n      let errorBody = \"\";\n      let errorJson;\n      try {\n        errorBody = await response.text();\n        errorJson = JSON.parse(errorBody);\n      } catch (e) {\n        throw new Error(\n          `HTTP error establishing stream for ${method}: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`,\n          { cause: e }\n        );\n      }\n      if (errorJson.error) {\n        throw new Error(\n          `HTTP error establishing stream for ${method}: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`\n        );\n      }\n      throw new Error(\n        `HTTP error establishing stream for ${method}: ${response.status} ${response.statusText}`\n      );\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\n        `Invalid response Content-Type for SSE stream for ${method}. Expected 'text/event-stream'.`\n      );\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  async *_parseA2ASseStream(response, originalRequestId) {\n    if (!response.body) {\n      throw new Error(\"SSE response body is undefined. Cannot read stream.\");\n    }\n    const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();\n    let buffer = \"\";\n    let eventDataBuffer = \"\";\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          if (eventDataBuffer.trim()) {\n            const result = this._processSseEventData(\n              eventDataBuffer,\n              originalRequestId\n            );\n            yield result;\n          }\n          break;\n        }\n        buffer += value;\n        let lineEndIndex;\n        while ((lineEndIndex = buffer.indexOf(\"\\n\")) >= 0) {\n          const line = buffer.substring(0, lineEndIndex).trim();\n          buffer = buffer.substring(lineEndIndex + 1);\n          if (line === \"\") {\n            if (eventDataBuffer) {\n              const result = this._processSseEventData(\n                eventDataBuffer,\n                originalRequestId\n              );\n              yield result;\n              eventDataBuffer = \"\";\n            }\n          } else if (line.startsWith(\"data:\")) {\n            eventDataBuffer += line.substring(5).trimStart() + \"\\n\";\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\n        \"Error reading or parsing SSE stream:\",\n        error instanceof Error && error.message || \"Error unknown\"\n      );\n      throw error;\n    } finally {\n      reader.releaseLock();\n    }\n  }\n  _processSseEventData(jsonData, originalRequestId) {\n    if (!jsonData.trim()) {\n      throw new Error(\"Attempted to process empty SSE event data.\");\n    }\n    try {\n      const sseJsonRpcResponse = JSON.parse(jsonData.replace(/\\n$/, \"\"));\n      const a2aStreamResponse = sseJsonRpcResponse;\n      if (a2aStreamResponse.id !== originalRequestId) {\n        console.warn(\n          `SSE Event's JSON-RPC response ID mismatch. Client request ID: ${originalRequestId}, event response ID: ${a2aStreamResponse.id}.`\n        );\n      }\n      if (\"error\" in a2aStreamResponse) {\n        const err = a2aStreamResponse.error;\n        throw new Error(\n          `SSE event contained an error: ${err.message} (Code: ${err.code}) Data: ${JSON.stringify(err.data || {})}`\n        );\n      }\n      if (!(\"result\" in a2aStreamResponse) || typeof a2aStreamResponse.result === \"undefined\") {\n        throw new Error(`SSE event JSON-RPC response is missing 'result' field. Data: ${jsonData}`);\n      }\n      return a2aStreamResponse.result;\n    } catch (e) {\n      if (e instanceof Error && (e.message.startsWith(\"SSE event contained an error\") || e.message.startsWith(\"SSE event JSON-RPC response is missing 'result' field\"))) {\n        throw e;\n      }\n      console.error(\n        \"Failed to parse SSE event data string or unexpected JSON-RPC structure:\",\n        jsonData,\n        e\n      );\n      throw new Error(\n        `Failed to parse SSE event data: \"${jsonData.substring(0, 100)}...\". Original error: ${e instanceof Error && e.message || \"Unknown error\"}`\n      );\n    }\n  }\n  static mapToError(response) {\n    switch (response.error.code) {\n      case -32001:\n        return new TaskNotFoundJSONRPCError(response);\n      case -32002:\n        return new TaskNotCancelableJSONRPCError(response);\n      case -32003:\n        return new PushNotificationNotSupportedJSONRPCError(response);\n      case -32004:\n        return new UnsupportedOperationJSONRPCError(response);\n      case -32005:\n        return new ContentTypeNotSupportedJSONRPCError(response);\n      case -32006:\n        return new InvalidAgentResponseJSONRPCError(response);\n      case -32007:\n        return new AuthenticatedExtendedCardNotConfiguredJSONRPCError(response);\n      default:\n        return new JSONRPCTransportError(response);\n    }\n  }\n};\nvar JsonRpcTransportFactory = class _JsonRpcTransportFactory {\n  constructor(options) {\n    this.options = options;\n  }\n  static name = \"JSONRPC\";\n  get protocolName() {\n    return _JsonRpcTransportFactory.name;\n  }\n  async create(url, _agentCard) {\n    return new JsonRpcTransport({\n      endpoint: url,\n      fetchImpl: this.options?.fetchImpl\n    });\n  }\n};\nvar JSONRPCTransportError = class extends Error {\n  constructor(errorResponse) {\n    super(\n      `JSON-RPC error: ${errorResponse.error.message} (Code: ${errorResponse.error.code}) Data: ${JSON.stringify(errorResponse.error.data || {})}`\n    );\n    this.errorResponse = errorResponse;\n  }\n};\nvar TaskNotFoundJSONRPCError = class extends TaskNotFoundError {\n  constructor(errorResponse) {\n    super();\n    this.errorResponse = errorResponse;\n  }\n};\nvar TaskNotCancelableJSONRPCError = class extends TaskNotCancelableError {\n  constructor(errorResponse) {\n    super();\n    this.errorResponse = errorResponse;\n  }\n};\nvar PushNotificationNotSupportedJSONRPCError = class extends PushNotificationNotSupportedError {\n  constructor(errorResponse) {\n    super();\n    this.errorResponse = errorResponse;\n  }\n};\nvar UnsupportedOperationJSONRPCError = class extends UnsupportedOperationError {\n  constructor(errorResponse) {\n    super();\n    this.errorResponse = errorResponse;\n  }\n};\nvar ContentTypeNotSupportedJSONRPCError = class extends ContentTypeNotSupportedError {\n  constructor(errorResponse) {\n    super();\n    this.errorResponse = errorResponse;\n  }\n};\nvar InvalidAgentResponseJSONRPCError = class extends InvalidAgentResponseError {\n  constructor(errorResponse) {\n    super();\n    this.errorResponse = errorResponse;\n  }\n};\nvar AuthenticatedExtendedCardNotConfiguredJSONRPCError = class extends AuthenticatedExtendedCardNotConfiguredError {\n  constructor(errorResponse) {\n    super();\n    this.errorResponse = errorResponse;\n  }\n};\n\n// src/client/client.ts\nvar A2AClient = class _A2AClient {\n  static emptyOptions = void 0;\n  agentCardPromise;\n  customFetchImpl;\n  serviceEndpointUrl;\n  // To be populated from AgentCard after fetchin\n  // A2AClient is built around JSON-RPC types, so it will only support JSON-RPC transport, new client with transport agnostic interface is going to be created for multi-transport.\n  // New transport abstraction isn't going to expose individual transport specific fields, so to keep returning JSON-RPC IDs here for compatibility,\n  // keep counter here and pass it to JsonRpcTransport via an optional idOverride parameter (which is not visible via transport-agnostic A2ATransport interface).\n  transport;\n  requestIdCounter = 1;\n  /**\n   * Constructs an A2AClient instance from an AgentCard.\n   * @param agentCard The AgentCard object.\n   * @param options Optional. The options for the A2AClient including the fetch/auth implementation.\n   */\n  constructor(agentCard, options) {\n    this.customFetchImpl = options?.fetchImpl;\n    if (typeof agentCard === \"string\") {\n      console.warn(\n        \"Warning: Constructing A2AClient with a URL is deprecated. Please use A2AClient.fromCardUrl() instead.\"\n      );\n      this.agentCardPromise = this._fetchAndCacheAgentCard(agentCard, options?.agentCardPath);\n    } else {\n      if (!agentCard.url) {\n        throw new Error(\n          \"Provided Agent Card does not contain a valid 'url' for the service endpoint.\"\n        );\n      }\n      this.serviceEndpointUrl = agentCard.url;\n      this.agentCardPromise = Promise.resolve(agentCard);\n    }\n  }\n  /**\n   * Dynamically resolves the fetch implementation to use for requests.\n   * Prefers a custom implementation if provided, otherwise falls back to the global fetch.\n   * @returns The fetch implementation.\n   * @param args Arguments to pass to the fetch implementation.\n   * @throws If no fetch implementation is available.\n   */\n  _fetch(...args) {\n    if (this.customFetchImpl) {\n      return this.customFetchImpl(...args);\n    }\n    if (typeof fetch === \"function\") {\n      return fetch(...args);\n    }\n    throw new Error(\n      \"A `fetch` implementation was not provided and is not available in the global scope. Please provide a `fetchImpl` in the A2AClientOptions. For earlier Node.js versions (pre-v18), you can use a library like `node-fetch`.\"\n    );\n  }\n  /**\n   * Creates an A2AClient instance by fetching the AgentCard from a URL then constructing the A2AClient.\n   * @param agentCardUrl The URL of the agent card.\n   * @param options Optional. The options for the A2AClient including the fetch/auth implementation.\n   * @returns A Promise that resolves to a new A2AClient instance.\n   */\n  static async fromCardUrl(agentCardUrl, options) {\n    const fetchImpl = options?.fetchImpl;\n    const requestInit = {\n      headers: { Accept: \"application/json\" }\n    };\n    let response;\n    if (fetchImpl) {\n      response = await fetchImpl(agentCardUrl, requestInit);\n    } else if (typeof fetch === \"function\") {\n      response = await fetch(agentCardUrl, requestInit);\n    } else {\n      throw new Error(\n        \"A `fetch` implementation was not provided and is not available in the global scope. Please provide a `fetchImpl` in the A2AClientOptions. For earlier Node.js versions (pre-v18), you can use a library like `node-fetch`.\"\n      );\n    }\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`\n      );\n    }\n    let agentCard;\n    try {\n      agentCard = await response.json();\n    } catch (error) {\n      console.error(\"Failed to parse Agent Card JSON:\", error);\n      throw new Error(\n        `Failed to parse Agent Card JSON from ${agentCardUrl}. Original error: ${error.message}`\n      );\n    }\n    return new _A2AClient(agentCard, options);\n  }\n  /**\n   * Sends a message to the agent.\n   * The behavior (blocking/non-blocking) and push notification configuration\n   * are specified within the `params.configuration` object.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * @param params The parameters for sending the message, including the message content and configuration.\n   * @returns A Promise resolving to SendMessageResponse, which can be a Message, Task, or an error.\n   */\n  async sendMessage(params) {\n    return await this.invokeJsonRpc(\n      (t, p, id) => t.sendMessage(p, _A2AClient.emptyOptions, id),\n      params\n    );\n  }\n  /**\n   * Sends a message to the agent and streams back responses using Server-Sent Events (SSE).\n   * Push notification configuration can be specified in `params.configuration`.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params The parameters for sending the message.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   * The generator throws an error if streaming is not supported or if an HTTP/SSE error occurs.\n   */\n  async *sendMessageStream(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\n        \"Agent does not support streaming (AgentCard.capabilities.streaming is not true).\"\n      );\n    }\n    const transport = await this._getOrCreateTransport();\n    yield* transport.sendMessageStream(params);\n  }\n  /**\n   * Sets or updates the push notification configuration for a given task.\n   * Requires the agent to support push notifications (`capabilities.pushNotifications: true` in AgentCard).\n   * @param params Parameters containing the taskId and the TaskPushNotificationConfig.\n   * @returns A Promise resolving to SetTaskPushNotificationConfigResponse.\n   */\n  async setTaskPushNotificationConfig(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.pushNotifications) {\n      throw new Error(\n        \"Agent does not support push notifications (AgentCard.capabilities.pushNotifications is not true).\"\n      );\n    }\n    return await this.invokeJsonRpc((t, p, id) => t.setTaskPushNotificationConfig(p, _A2AClient.emptyOptions, id), params);\n  }\n  /**\n   * Gets the push notification configuration for a given task.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to GetTaskPushNotificationConfigResponse.\n   */\n  async getTaskPushNotificationConfig(params) {\n    return await this.invokeJsonRpc(\n      (t, p, id) => t.getTaskPushNotificationConfig(p, _A2AClient.emptyOptions, id),\n      params\n    );\n  }\n  /**\n   * Lists the push notification configurations for a given task.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to ListTaskPushNotificationConfigResponse.\n   */\n  async listTaskPushNotificationConfig(params) {\n    return await this.invokeJsonRpc((t, p, id) => t.listTaskPushNotificationConfig(p, _A2AClient.emptyOptions, id), params);\n  }\n  /**\n   * Deletes the push notification configuration for a given task.\n   * @param params Parameters containing the taskId and push notification configuration ID.\n   * @returns A Promise resolving to DeleteTaskPushNotificationConfigResponse.\n   */\n  async deleteTaskPushNotificationConfig(params) {\n    return await this.invokeJsonRpc((t, p, id) => t.deleteTaskPushNotificationConfig(p, _A2AClient.emptyOptions, id), params);\n  }\n  /**\n   * Retrieves a task by its ID.\n   * @param params Parameters containing the taskId and optional historyLength.\n   * @returns A Promise resolving to GetTaskResponse, which contains the Task object or an error.\n   */\n  async getTask(params) {\n    return await this.invokeJsonRpc(\n      (t, p, id) => t.getTask(p, _A2AClient.emptyOptions, id),\n      params\n    );\n  }\n  /**\n   * Cancels a task by its ID.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to CancelTaskResponse, which contains the updated Task object or an error.\n   */\n  async cancelTask(params) {\n    return await this.invokeJsonRpc(\n      (t, p, id) => t.cancelTask(p, _A2AClient.emptyOptions, id),\n      params\n    );\n  }\n  /**\n   * @template TExtensionParams The type of parameters for the custom extension method.\n   * @template TExtensionResponse The type of response expected from the custom extension method.\n   * This should extend JSONRPCResponse. This ensures the extension response is still a valid A2A response.\n   * @param method Custom JSON-RPC method defined in the AgentCard's extensions.\n   * @param params Extension paramters defined in the AgentCard's extensions.\n   * @returns A Promise that resolves to the RPC response.\n   */\n  async callExtensionMethod(method, params) {\n    const transport = await this._getOrCreateTransport();\n    try {\n      return await transport.callExtensionMethod(\n        method,\n        params,\n        this.requestIdCounter++\n      );\n    } catch (e) {\n      const errorResponse = extractJSONRPCError(e);\n      if (errorResponse) {\n        return errorResponse;\n      }\n      throw e;\n    }\n  }\n  /**\n   * Resubscribes to a task's event stream using Server-Sent Events (SSE).\n   * This is used if a previous SSE connection for an active task was broken.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params Parameters containing the taskId.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   */\n  async *resubscribeTask(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (required for tasks/resubscribe).\");\n    }\n    const transport = await this._getOrCreateTransport();\n    yield* transport.resubscribeTask(params);\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n  // Functions used to support old A2AClient Constructor to be deprecated soon\n  // TODOs:\n  // * remove `agentCardPromise`, and just use agentCard initialized\n  // * _getServiceEndpoint can be made synchronous or deleted and accessed via\n  //   agentCard.url\n  // * getAgentCard changed to this.agentCard\n  // * delete resolveAgentCardUrl(), _fetchAndCacheAgentCard(),\n  //   agentCardPath from A2AClientOptions\n  // * delete _getOrCreateTransport\n  ////////////////////////////////////////////////////////////////////////////////\n  async _getOrCreateTransport() {\n    if (this.transport) {\n      return this.transport;\n    }\n    const endpoint = await this._getServiceEndpoint();\n    this.transport = new JsonRpcTransport({ fetchImpl: this.customFetchImpl, endpoint });\n    return this.transport;\n  }\n  /**\n   * Fetches the Agent Card from the agent's well-known URI and caches its service endpoint URL.\n   * This method is called by the constructor.\n   * @param agentBaseUrl The base URL of the A2A agent (e.g., https://agent.example.com)\n   * @param agentCardPath path to the agent card, defaults to .well-known/agent-card.json\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async _fetchAndCacheAgentCard(agentBaseUrl, agentCardPath) {\n    try {\n      const agentCardUrl = this.resolveAgentCardUrl(agentBaseUrl, agentCardPath);\n      const response = await this._fetch(agentCardUrl, {\n        headers: { Accept: \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(\n          `Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`\n        );\n      }\n      const agentCard = await response.json();\n      if (!agentCard.url) {\n        throw new Error(\n          \"Fetched Agent Card does not contain a valid 'url' for the service endpoint.\"\n        );\n      }\n      this.serviceEndpointUrl = agentCard.url;\n      return agentCard;\n    } catch (error) {\n      console.error(\"Error fetching or parsing Agent Card:\", error);\n      throw error;\n    }\n  }\n  /**\n   * Retrieves the Agent Card.\n   * If an `agentBaseUrl` is provided, it fetches the card from that specific URL.\n   * Otherwise, it returns the card fetched and cached during client construction.\n   * @param agentBaseUrl Optional. The base URL of the agent to fetch the card from.\n   * @param agentCardPath path to the agent card, defaults to .well-known/agent-card.json\n   * If provided, this will fetch a new card, not use the cached one from the constructor's URL.\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async getAgentCard(agentBaseUrl, agentCardPath) {\n    if (agentBaseUrl) {\n      const agentCardUrl = this.resolveAgentCardUrl(agentBaseUrl, agentCardPath);\n      const response = await this._fetch(agentCardUrl, {\n        headers: { Accept: \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(\n          `Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`\n        );\n      }\n      return await response.json();\n    }\n    return this.agentCardPromise;\n  }\n  /**\n   * Determines the agent card URL based on the agent URL.\n   * @param agentBaseUrl The agent URL.\n   * @param agentCardPath Optional relative path to the agent card, defaults to .well-known/agent-card.json\n   */\n  resolveAgentCardUrl(agentBaseUrl, agentCardPath = AGENT_CARD_PATH) {\n    return `${agentBaseUrl.replace(/\\/$/, \"\")}/${agentCardPath.replace(/^\\//, \"\")}`;\n  }\n  /**\n   * Gets the RPC service endpoint URL. Ensures the agent card has been fetched first.\n   * @returns A Promise that resolves to the service endpoint URL string.\n   */\n  async _getServiceEndpoint() {\n    if (this.serviceEndpointUrl) {\n      return this.serviceEndpointUrl;\n    }\n    await this.agentCardPromise;\n    if (!this.serviceEndpointUrl) {\n      throw new Error(\n        \"Agent Card URL for RPC endpoint is not available. Fetching might have failed.\"\n      );\n    }\n    return this.serviceEndpointUrl;\n  }\n  async invokeJsonRpc(caller, params) {\n    const transport = await this._getOrCreateTransport();\n    const requestId = this.requestIdCounter++;\n    try {\n      const result = await caller(transport, params, requestId);\n      return {\n        id: requestId,\n        jsonrpc: \"2.0\",\n        result: result ?? null\n        // JSON-RPC requires result property on success, it will be null for \"void\" methods.\n      };\n    } catch (e) {\n      const errorResponse = extractJSONRPCError(e);\n      if (errorResponse) {\n        return errorResponse;\n      }\n      throw e;\n    }\n  }\n};\nfunction extractJSONRPCError(error) {\n  if (error instanceof Object && \"errorResponse\" in error && error.errorResponse instanceof Object && \"jsonrpc\" in error.errorResponse && error.errorResponse.jsonrpc === \"2.0\" && \"error\" in error.errorResponse && error.errorResponse.error !== null) {\n    return error.errorResponse;\n  } else {\n    return void 0;\n  }\n}\n\n// src/client/auth-handler.ts\nfunction createAuthenticatingFetchWithRetry(fetchImpl, authHandler) {\n  async function authFetch(url, init) {\n    const authHeaders = await authHandler.headers() || {};\n    const mergedInit = {\n      ...init || {},\n      headers: {\n        ...authHeaders,\n        ...init?.headers || {}\n      }\n    };\n    let response = await fetchImpl(url, mergedInit);\n    const updatedHeaders = await authHandler.shouldRetryWithHeaders(mergedInit, response);\n    if (updatedHeaders) {\n      const retryInit = {\n        ...init || {},\n        headers: {\n          ...updatedHeaders,\n          ...init?.headers || {}\n        }\n      };\n      response = await fetchImpl(url, retryInit);\n      if (response.ok && authHandler.onSuccessfulRetry) {\n        await authHandler.onSuccessfulRetry(updatedHeaders);\n      }\n    }\n    return response;\n  }\n  Object.setPrototypeOf(authFetch, Object.getPrototypeOf(fetchImpl));\n  Object.defineProperties(authFetch, Object.getOwnPropertyDescriptors(fetchImpl));\n  return authFetch;\n}\n\n// src/client/card-resolver.ts\nvar DefaultAgentCardResolver = class {\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Fetches the agent card based on provided base URL and path.\n   * Path is selected in the following order:\n   * 1) path parameter\n   * 2) path from options\n   * 3) .well-known/agent-card.json\n   */\n  async resolve(baseUrl, path) {\n    const agentCardUrl = new URL(path ?? this.options?.path ?? AGENT_CARD_PATH, baseUrl);\n    const response = await this.fetchImpl(agentCardUrl);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status}`);\n    }\n    return await response.json();\n  }\n  fetchImpl(...args) {\n    if (this.options?.fetchImpl) {\n      return this.options.fetchImpl(...args);\n    }\n    return fetch(...args);\n  }\n};\nvar AgentCardResolver = {\n  default: new DefaultAgentCardResolver()\n};\n\n// src/client/multitransport-client.ts\nvar Client = class {\n  constructor(transport, agentCard, config) {\n    this.transport = transport;\n    this.agentCard = agentCard;\n    this.config = config;\n  }\n  /**\n   * If the current agent card supports the extended feature, it will try to fetch the extended agent card from the server,\n   * Otherwise it will return the current agent card value.\n   */\n  async getAgentCard(options) {\n    if (this.agentCard.supportsAuthenticatedExtendedCard) {\n      this.agentCard = await this.executeWithInterceptors(\n        { method: \"getAgentCard\" },\n        options,\n        (_, options2) => this.transport.getExtendedAgentCard(options2)\n      );\n    }\n    return this.agentCard;\n  }\n  /**\n   * Sends a message to an agent to initiate a new interaction or to continue an existing one.\n   * Uses blocking mode by default.\n   */\n  sendMessage(params, options) {\n    params = this.applyClientConfig({\n      params,\n      blocking: !(this.config?.polling ?? false)\n    });\n    return this.executeWithInterceptors(\n      { method: \"sendMessage\", value: params },\n      options,\n      this.transport.sendMessage.bind(this.transport)\n    );\n  }\n  /**\n   * Sends a message to an agent to initiate/continue a task AND subscribes the client to real-time updates for that task.\n   * Performs fallback to non-streaming if not supported by the agent.\n   */\n  async *sendMessageStream(params, options) {\n    const method = \"sendMessageStream\";\n    params = this.applyClientConfig({ params, blocking: true });\n    const beforeArgs = {\n      input: { method, value: params },\n      agentCard: this.agentCard,\n      options\n    };\n    const beforeResult = await this.interceptBefore(beforeArgs);\n    if (beforeResult) {\n      const earlyReturn = beforeResult.earlyReturn.value;\n      const afterArgs = {\n        result: { method, value: earlyReturn },\n        agentCard: this.agentCard,\n        options: beforeArgs.options\n      };\n      await this.interceptAfter(afterArgs, beforeResult.executed);\n      yield afterArgs.result.value;\n      return;\n    }\n    if (!this.agentCard.capabilities.streaming) {\n      const result = await this.transport.sendMessage(beforeArgs.input.value, beforeArgs.options);\n      const afterArgs = {\n        result: { method, value: result },\n        agentCard: this.agentCard,\n        options: beforeArgs.options\n      };\n      await this.interceptAfter(afterArgs);\n      yield afterArgs.result.value;\n      return;\n    }\n    for await (const event of this.transport.sendMessageStream(\n      beforeArgs.input.value,\n      beforeArgs.options\n    )) {\n      const afterArgs = {\n        result: { method, value: event },\n        agentCard: this.agentCard,\n        options: beforeArgs.options\n      };\n      await this.interceptAfter(afterArgs);\n      yield afterArgs.result.value;\n      if (afterArgs.earlyReturn) {\n        return;\n      }\n    }\n  }\n  /**\n   * Sets or updates the push notification configuration for a specified task.\n   * Requires the server to have AgentCard.capabilities.pushNotifications: true.\n   */\n  setTaskPushNotificationConfig(params, options) {\n    if (!this.agentCard.capabilities.pushNotifications) {\n      throw new PushNotificationNotSupportedError();\n    }\n    return this.executeWithInterceptors(\n      { method: \"setTaskPushNotificationConfig\", value: params },\n      options,\n      this.transport.setTaskPushNotificationConfig.bind(this.transport)\n    );\n  }\n  /**\n   * Retrieves the current push notification configuration for a specified task.\n   * Requires the server to have AgentCard.capabilities.pushNotifications: true.\n   */\n  getTaskPushNotificationConfig(params, options) {\n    if (!this.agentCard.capabilities.pushNotifications) {\n      throw new PushNotificationNotSupportedError();\n    }\n    return this.executeWithInterceptors(\n      { method: \"getTaskPushNotificationConfig\", value: params },\n      options,\n      this.transport.getTaskPushNotificationConfig.bind(this.transport)\n    );\n  }\n  /**\n   * Retrieves the associated push notification configurations for a specified task.\n   * Requires the server to have AgentCard.capabilities.pushNotifications: true.\n   */\n  listTaskPushNotificationConfig(params, options) {\n    if (!this.agentCard.capabilities.pushNotifications) {\n      throw new PushNotificationNotSupportedError();\n    }\n    return this.executeWithInterceptors(\n      { method: \"listTaskPushNotificationConfig\", value: params },\n      options,\n      this.transport.listTaskPushNotificationConfig.bind(this.transport)\n    );\n  }\n  /**\n   * Deletes an associated push notification configuration for a task.\n   */\n  deleteTaskPushNotificationConfig(params, options) {\n    return this.executeWithInterceptors(\n      { method: \"deleteTaskPushNotificationConfig\", value: params },\n      options,\n      this.transport.deleteTaskPushNotificationConfig.bind(this.transport)\n    );\n  }\n  /**\n   * Retrieves the current state (including status, artifacts, and optionally history) of a previously initiated task.\n   */\n  getTask(params, options) {\n    return this.executeWithInterceptors(\n      { method: \"getTask\", value: params },\n      options,\n      this.transport.getTask.bind(this.transport)\n    );\n  }\n  /**\n   * Requests the cancellation of an ongoing task. The server will attempt to cancel the task,\n   * but success is not guaranteed (e.g., the task might have already completed or failed, or cancellation might not be supported at its current stage).\n   */\n  cancelTask(params, options) {\n    return this.executeWithInterceptors(\n      { method: \"cancelTask\", value: params },\n      options,\n      this.transport.cancelTask.bind(this.transport)\n    );\n  }\n  /**\n   * Allows a client to reconnect to an updates stream for an ongoing task after a previous connection was interrupted.\n   */\n  async *resubscribeTask(params, options) {\n    const method = \"resubscribeTask\";\n    const beforeArgs = {\n      input: { method, value: params },\n      agentCard: this.agentCard,\n      options\n    };\n    const beforeResult = await this.interceptBefore(beforeArgs);\n    if (beforeResult) {\n      const earlyReturn = beforeResult.earlyReturn.value;\n      const afterArgs = {\n        result: { method, value: earlyReturn },\n        agentCard: this.agentCard,\n        options: beforeArgs.options\n      };\n      await this.interceptAfter(afterArgs, beforeResult.executed);\n      yield afterArgs.result.value;\n      return;\n    }\n    for await (const event of this.transport.resubscribeTask(\n      beforeArgs.input.value,\n      beforeArgs.options\n    )) {\n      const afterArgs = {\n        result: { method, value: event },\n        agentCard: this.agentCard,\n        options: beforeArgs.options\n      };\n      await this.interceptAfter(afterArgs);\n      yield afterArgs.result.value;\n      if (afterArgs.earlyReturn) {\n        return;\n      }\n    }\n  }\n  applyClientConfig({\n    params,\n    blocking\n  }) {\n    const result = { ...params, configuration: params.configuration ?? {} };\n    if (!result.configuration.acceptedOutputModes && this.config?.acceptedOutputModes) {\n      result.configuration.acceptedOutputModes = this.config.acceptedOutputModes;\n    }\n    if (!result.configuration.pushNotificationConfig && this.config?.pushNotificationConfig) {\n      result.configuration.pushNotificationConfig = this.config.pushNotificationConfig;\n    }\n    result.configuration.blocking ??= blocking;\n    return result;\n  }\n  async executeWithInterceptors(input, options, transportCall) {\n    const beforeArgs = {\n      input,\n      agentCard: this.agentCard,\n      options\n    };\n    const beforeResult = await this.interceptBefore(beforeArgs);\n    if (beforeResult) {\n      const afterArgs2 = {\n        result: {\n          method: input.method,\n          value: beforeResult.earlyReturn.value\n        },\n        agentCard: this.agentCard,\n        options: beforeArgs.options\n      };\n      await this.interceptAfter(afterArgs2, beforeResult.executed);\n      return afterArgs2.result.value;\n    }\n    const result = await transportCall(beforeArgs.input.value, beforeArgs.options);\n    const afterArgs = {\n      result: { method: input.method, value: result },\n      agentCard: this.agentCard,\n      options: beforeArgs.options\n    };\n    await this.interceptAfter(afterArgs);\n    return afterArgs.result.value;\n  }\n  async interceptBefore(args) {\n    if (!this.config?.interceptors || this.config.interceptors.length === 0) {\n      return;\n    }\n    const executed = [];\n    for (const interceptor of this.config.interceptors) {\n      await interceptor.before(args);\n      executed.push(interceptor);\n      if (args.earlyReturn) {\n        return {\n          earlyReturn: args.earlyReturn,\n          executed\n        };\n      }\n    }\n  }\n  async interceptAfter(args, interceptors) {\n    const reversedInterceptors = [...interceptors ?? this.config?.interceptors ?? []].reverse();\n    for (const interceptor of reversedInterceptors) {\n      await interceptor.after(args);\n      if (args.earlyReturn) {\n        return;\n      }\n    }\n  }\n};\n\n// src/client/factory.ts\nvar ClientFactoryOptions = {\n  /**\n   * SDK default options for {@link ClientFactory}.\n   */\n  default: {\n    transports: [new JsonRpcTransportFactory()]\n  },\n  /**\n   * Creates new options by merging an original and an override object.\n   * Transports are merged based on `TransportFactory.protocolName`,\n   * interceptors are concatenated, other fields are overriden.\n   *\n   * @example\n   * ```ts\n   * const options = ClientFactoryOptions.createFrom(ClientFactoryOptions.default, {\n   *  transports: [new MyCustomTransportFactory()], // adds a custom transport\n   *  clientConfig: { interceptors: [new MyInterceptor()] }, // adds a custom interceptor\n   * });\n   * ```\n   */\n  createFrom(original, overrides) {\n    return {\n      ...original,\n      ...overrides,\n      transports: mergeTransports(original.transports, overrides.transports),\n      clientConfig: {\n        ...original.clientConfig ?? {},\n        ...overrides.clientConfig ?? {},\n        interceptors: mergeArrays(\n          original.clientConfig?.interceptors,\n          overrides.clientConfig?.interceptors\n        ),\n        acceptedOutputModes: overrides.clientConfig?.acceptedOutputModes ?? original.clientConfig?.acceptedOutputModes\n      },\n      preferredTransports: overrides.preferredTransports ?? original.preferredTransports\n    };\n  }\n};\nvar ClientFactory = class {\n  constructor(options = ClientFactoryOptions.default) {\n    this.options = options;\n    if (!options.transports || options.transports.length === 0) {\n      throw new Error(\"No transports provided\");\n    }\n    this.transportsByName = transportsByName(options.transports);\n    for (const transport of options.preferredTransports ?? []) {\n      const factory = this.options.transports.find((t) => t.protocolName === transport);\n      if (!factory) {\n        throw new Error(\n          `Unknown preferred transport: ${transport}, available transports: ${[...this.transportsByName.keys()].join()}`\n        );\n      }\n    }\n    this.agentCardResolver = options.cardResolver ?? AgentCardResolver.default;\n  }\n  transportsByName;\n  agentCardResolver;\n  /**\n   * Creates a new client from the provided agent card.\n   */\n  async createFromAgentCard(agentCard) {\n    const agentCardPreferred = agentCard.preferredTransport ?? JsonRpcTransportFactory.name;\n    const additionalInterfaces = agentCard.additionalInterfaces ?? [];\n    const urlsPerAgentTransports = new Map([\n      [agentCardPreferred, agentCard.url],\n      ...additionalInterfaces.map((i) => [i.transport, i.url])\n    ]);\n    const transportsByPreference = [\n      ...this.options.preferredTransports ?? [],\n      agentCardPreferred,\n      ...additionalInterfaces.map((i) => i.transport)\n    ];\n    for (const transport of transportsByPreference) {\n      if (!urlsPerAgentTransports.has(transport)) {\n        continue;\n      }\n      const factory = this.transportsByName.get(transport);\n      if (!factory) {\n        continue;\n      }\n      return new Client(\n        await factory.create(urlsPerAgentTransports.get(transport), agentCard),\n        agentCard,\n        this.options.clientConfig\n      );\n    }\n    throw new Error(\n      \"No compatible transport found, available transports: \" + [...this.transportsByName.keys()].join()\n    );\n  }\n  /**\n   * Downloads agent card using AgentCardResolver from options\n   * and creates a new client from the downloaded card.\n   *\n   * @example\n   * ```ts\n   * const factory = new ClientFactory(); // use default options and default {@link AgentCardResolver}.\n   * const client1 = await factory.createFromUrl('https://example.com'); // /.well-known/agent-card.json is used by default\n   * const client2 = await factory.createFromUrl('https://example.com', '/my-agent-card.json'); // specify custom path\n   * const client3 = await factory.createFromUrl('https://example.com/my-agent-card.json', ''); // specify full URL and set path to empty\n   * ```\n   */\n  async createFromUrl(baseUrl, path) {\n    const agentCard = await this.agentCardResolver.resolve(baseUrl, path);\n    return this.createFromAgentCard(agentCard);\n  }\n};\nfunction mergeTransports(original, overrides) {\n  if (!overrides) {\n    return original;\n  }\n  const result = transportsByName(original);\n  const overridesByName = transportsByName(overrides);\n  for (const [name, factory] of overridesByName) {\n    result.set(name, factory);\n  }\n  return Array.from(result.values());\n}\nfunction transportsByName(transports) {\n  const result = /* @__PURE__ */ new Map();\n  if (!transports) {\n    return result;\n  }\n  for (const t of transports) {\n    if (result.has(t.protocolName)) {\n      throw new Error(`Duplicate protocol name: ${t.protocolName}`);\n    }\n    result.set(t.protocolName, t);\n  }\n  return result;\n}\nfunction mergeArrays(a1, a2) {\n  if (!a1 && !a2) {\n    return void 0;\n  }\n  return [...a1 ?? [], ...a2 ?? []];\n}\n\n// src/client/service-parameters.ts\nvar ServiceParameters = {\n  create(...updates) {\n    return ServiceParameters.createFrom(void 0, ...updates);\n  },\n  createFrom: (serviceParameters, ...updates) => {\n    const result = serviceParameters ? { ...serviceParameters } : {};\n    for (const update of updates) {\n      update(result);\n    }\n    return result;\n  }\n};\nfunction withA2AExtensions(...extensions) {\n  return (parameters) => {\n    parameters[HTTP_EXTENSION_HEADER] = Extensions.toServiceParameter(extensions);\n  };\n}\n\n// src/client/context.ts\nvar ClientCallContext = {\n  /**\n   * Create a new {@link ClientCallContext} with optional updates applied.\n   */\n  create: (...updates) => {\n    return ClientCallContext.createFrom(void 0, ...updates);\n  },\n  /**\n   * Create a new {@link ClientCallContext} based on an existing one with updates applied.\n   */\n  createFrom: (context, ...updates) => {\n    const result = context ? { ...context } : {};\n    for (const update of updates) {\n      update(result);\n    }\n    return result;\n  }\n};\nvar ClientCallContextKey = class {\n  symbol;\n  constructor(description) {\n    this.symbol = Symbol(description);\n  }\n  set(value) {\n    return (context) => {\n      context[this.symbol] = value;\n    };\n  }\n  get(context) {\n    return context[this.symbol];\n  }\n};\nexport {\n  A2AClient,\n  AgentCardResolver,\n  Client,\n  ClientCallContext,\n  ClientCallContextKey,\n  ClientFactory,\n  ClientFactoryOptions,\n  DefaultAgentCardResolver,\n  JsonRpcTransport,\n  JsonRpcTransportFactory,\n  ServiceParameters,\n  createAuthenticatingFetchWithRetry,\n  withA2AExtensions\n};\n"],
  "mappings": "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",
  "names": []
}
