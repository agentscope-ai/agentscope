(211-web-cn)=
# 在AgentScope中启用网页浏览功能
在这里，我们介绍了如何在AgentScope中实现网页浏览功能。
我们实现的两个模块简单明了：**web browser** 和 **web browsing agent**。
web browser作为网页的接口，而配备了web browser的web browsing agent可以利用基于视觉的LLM的强大功能执行网页浏览任务。

请注意，AgentScope所提供的网页浏览功能仍处于beta阶段。
我们将不断完善该模块，并在我们的代码库和文档中提供相应的更新。

现在，让我们详细看看web browser和web browsing agent。

## Web Browser接口

我们实现的`WebBrowser`类是一个简单的网页接口。它可以打开一个网页，点击元素，在元素中输入内容，截图等。

`WebBrowser`类实现在[web_browser.py](https://github.com/modelscope/agentscope/blob/main/src/agentscope/browser/web_browser.py) 中。

### 前提条件

`WebBrowser`类通过Playwright操作浏览器。
要使用web browser，你需要安装必要的Playwright包：
- 运行 `pip install playwright` 设置Python环境。
- 运行 `playwright install` 安装Playwright所需的浏览器。

### 用法

我们提供的web browser拥有简单的接口。要使用web browser，我们只需创建并使用定义好的方法接口。

#### 如何创建Web Browser实例

你可以使用`WebBrowser`的`__init__`函数初始化`WebBrowser`实例：
```python
browser = WebBrowser()
```

（可选）你还可以在初始化时设置浏览器实例的特定属性：
- `headless`：决定是否以headless模式运行浏览器。默认值为`False`。设置为`False`时，浏览器对用户可见。
- `timeout`：浏览器等待页面加载的时间。默认值为`60000`。
- `default_width`：浏览器的默认宽度。默认值为`1280`。
- `default_height`：浏览器的默认高度。默认值为`1080`。

#### 定义的浏览器接口

目前，`WebBrowser`定义的方法有：`visit_page`，`crawl_page`，`click`，`type`，`scroll`，`press_key`，`close`等。浏览器的属性包括`url`，`page_html`，`page_title`等。

由于空间限制，这里不提供每个方法接口的详细介绍，但你可以参考Sphinx API文档和内联注释了解更多细节。
相反，我们将提供有关如何使用web browser模块的一般指导。

#### 我们的`WebBrowser`如何工作？

要使用我们的web browser，你首先需要访问一个网页，然后爬取页面以获取元素，最后与这些元素进行交互。

##### 访问网页

**首先**，你可以使用`browser.visit_page(url)`启动浏览器并访问你感兴趣的页面。通过使用`click`或`type`方法也可以触发网页导航。

##### 爬取页面

**然后**，你应该调用`crawl_page`方法来获取当前网页的元素。
我们web browser的一个关键特性是，我们用数字标记网页上的交互元素，这在`crawl_page`方法中实现。

通过标记的元素，你可以确保浏览器与页面上的正确元素进行交互，使用类似`click`，`type`和`focus_element`的方法。`crawl_page`方法后，交互元素将被数字标记，并存储在`WebBrowser`实例的`self.page_elements`属性中。然后你可以使用类似`click`，`type`和`focus_element`的方法与这些元素进行交互。

`crawl_page` 方法有三个输入参数和四个返回值。你可以选择是否使用vision向网页添加Set-of-Marks，以及是否在返回的格式化文本中包含`meta_data`字段。

> Set-of-Mark是一种视觉提示方法，它将图像分成编号的区域，以提高LLMs的视觉定位能力。你可以参阅论文https://arxiv.org/abs/2310.11441了解详细信息。或者可以查看[我们的示例](https://github.com/modelscope/agentscope/blob/main/examples/conversation_with_web_voyager_agent/README.md)中的演示。

`crawl_page` 的输入参数：

- `vision`（`bool`）：如果启用vision，则向网页添加set-of-marks并截图。我们使用本地JavaScript将网页上的交互元素进行边界划分，而不是使用分割模型。
- `with_meta`（`bool`）：包括`meta_data`字段在返回的格式化文本中。
- `with_select`（`bool`）：只返回选定的交互元素或所有编号的交互元素。

`crawl_page` 的返回值：

- `elements`：来源于Playwright的交互元素处理程序，也存储在`WebBrowser`实例的`self.page_elements`属性中。
- `format_ele_text`：格式化的元素文本描述列表，从零开始编号。
- `screenshot_bytes`：网页的带Set-of-Marks的截图，以字节形式。如果你想使用基于视觉的MLLM，请使用我们提供的`file_manager`模块将截图保存到文件，并使用格式函数提供图像路径。
- `web_ele_infos`：交互元素的信息字典。

##### 执行操作

**最后**，你可以调用诸如`click`，`type`，`focus_element`等方法与标记的交互元素进行交互。
例如：
```python
browser.click(element_id)
```

```python
browser.type(element_id, "Hello, World!")
```

还可以调用其他方法如`scroll`，`press_key`，`close`。
你可以参考API文档或[原始代码](https://github.com/modelscope/agentscope/blob/main/src/agentscope/browser/web_browser.py)了解更多细节。

### Web Browsing Agent

我们实现的`WebVoyagerAgent`是一个简单的Agent，可以执行网页浏览任务。它实现在[web_voyager_agent.py](https://github.com/modelscope/agentscope/blob/main/src/agentscope/agents/web_voyager_agent.py)。

Agent的响应函数实现在`WebVoyagerAgent`类的 `reply` 方法中，遵循以下步骤：1. 访问网页 -> 2. 爬取页面 -> 3. 执行操作 -> 4. 重复迭代直到实现目标。

你可以在[我们的示例](https://github.com/modelscope/agentscope/blob/main/examples/conversation_with_web_voyager_agent/)中尝试与Agent交互。

由于该模块仍处于beta阶段，目前实现的Agent远非完美。如果你有能力的话，你可以尝试改进它，甚至可以自己构建一个Agent。

希望你可以享受使用我们的Agent浏览网页吧！

[[回到顶部]](#211-web-cn)
